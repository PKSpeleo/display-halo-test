<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MacBook Pro 16 M3 Max – Retina Pixel Test</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background: #000000; /* Absolutely black background */
            overflow: hidden;    /* No scrollbars */
        }

        /* Fullscreen black wrapper */
        #wrapper {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000; /* Absolutely black background */
            overflow: hidden;
        }

        /* Inner border (hairline) to approximate 1 physical pixel on Retina */
        #frame {
            position: absolute;
            top: 1px;
            left: 1px;
            right: 1px;
            bottom: 1px;
            border: 0.5px solid #FFFFFF; /* Absolutely white border (hairline) */
            box-sizing: border-box;
            background: transparent;
            display: none; /* Base visibility (toggled by Space key) */
            pointer-events: none;
        }

        /* Moving pixel-like dots, also hairline-sized */
        .pixel-dot {
            position: absolute;
            left: 0;
            top: 0;
            width: 0.5px;   /* Hairline size: ~1 physical pixel on Retina */
            height: 0.5px;  /* Hairline size: ~1 physical pixel on Retina */
            background-color: #FFFFFF;
            display: none;  /* Toggled by number keys 1–4 */
            pointer-events: none;
        }

        /* HUD with state info in the bottom-right corner (visible only when base frame is enabled) */
        #hud {
            position: absolute;
            right: 8px;
            bottom: 8px;
            padding: 6px 8px;
            background: rgba(0, 0, 0, 0.6);
            color: #FFFFFF;
            font-family: monospace;
            font-size: 11px;
            line-height: 1.4;
            white-space: pre;
            pointer-events: none;
            display: none; /* Shown only when base frame is visible */
            text-align: right;
            max-width: 50%;
        }
    </style>
</head>
<body>
<div id="wrapper">
    <!-- Pixel dots for keys 1–4 -->
    <div id="dot1" class="pixel-dot"></div> <!-- Red -->
    <div id="dot2" class="pixel-dot"></div> <!-- Green -->
    <div id="dot3" class="pixel-dot"></div> <!-- Cyan -->
    <div id="dot4" class="pixel-dot"></div> <!-- White -->

    <!-- Inner frame that can blink on collisions -->
    <div id="frame"></div>

    <!-- HUD with status info (bottom-right corner) -->
    <div id="hud"></div>
</div>

<script>
    (function () {
        const wrapper = document.getElementById('wrapper');
        const frame = document.getElementById('frame');
        const hud = document.getElementById('hud');

        // Dot configuration per key
        const dotConfigs = {
            '1': { id: 'dot1', color: '#FF0000' }, // Red
            '2': { id: 'dot2', color: '#00FF00' }, // Green
            '3': { id: 'dot3', color: '#00FFFF' }, // Cyan (Blue-like)
            '4': { id: 'dot4', color: '#FFFFFF' }  // White
        };

        // Human-readable labels with colors
        const dotLabels = {
            '1': '1 (R)',
            '2': '2 (G)',
            '3': '3 (B)',
            '4': '4 (W)'
        };

        // State for each dot (position, velocity, etc.)
        const dots = {};

        // Viewport size in CSS pixels
        let viewportWidth = 0;
        let viewportHeight = 0;

        // Frame visibility and flashing
        let frameBaseVisible = false;       // Controlled by Space key
        const frameBaseColor = '#FFFFFF';
        const hudBaseColor = '#FFFFFF';
        let frameFlashEndTime = 0;          // Timestamp when flash should end
        let frameFlashActive = false;       // True while flash is active

        // Initialize dots
        for (const key in dotConfigs) {
            const cfg = dotConfigs[key];
            const el = document.getElementById(cfg.id);
            dots[key] = {
                key: key,
                element: el,
                color: cfg.color,
                active: false,
                x: 0,
                y: 0,
                vx: 0,
                vy: 0
            };
        }

        // Log current state to the console and update HUD text
        function logState() {
            const activeLabels = [];
            for (const key in dots) {
                if (dots[key].active) {
                    activeLabels.push(dotLabels[key] || key);
                }
            }

            const dpr = window.devicePixelRatio || 1;

            const stateLines = [
                'Frame base visible: ' + frameBaseVisible,
                'Frame flash active: ' + frameFlashActive,
                'Active pixels: ' + (activeLabels.length ? activeLabels.join(', ') : 'none'),
                'Viewport: ' + viewportWidth + ' x ' + viewportHeight,
                'devicePixelRatio: ' + dpr
            ];

            console.log('--- STATE ---');
            stateLines.forEach(line => console.log(line));
            console.log('---------------');

            // Update HUD text; HUD visibility is controlled elsewhere
            hud.textContent = stateLines.join('\n');
        }

        // Apply base visibility to frame and HUD (only used when no flash is active)
        function applyBaseFrameVisibility() {
            if (frameBaseVisible) {
                frame.style.display = 'block';
                frame.style.borderColor = frameBaseColor;
                hud.style.display = 'block';  // Show HUD when base frame is enabled
            } else {
                frame.style.display = 'none';
                frame.style.borderColor = frameBaseColor;
                hud.style.display = 'none';   // Hide HUD when base frame is disabled
            }
            // When we apply base visibility, we also ensure base HUD color
            if (!frameFlashActive) {
                hud.style.color = hudBaseColor;
            }
        }

        function resizeToViewport() {
            viewportWidth = window.innerWidth;
            viewportHeight = window.innerHeight;

            // Set wrapper size exactly to the current viewport
            wrapper.style.width = viewportWidth + 'px';
            wrapper.style.height = viewportHeight + 'px';

            const dpr = window.devicePixelRatio || 1;

            // Debug info: viewport size and DPR
            console.clear();
            console.log('Viewport (window.innerWidth x window.innerHeight): ' +
                viewportWidth + ' x ' + viewportHeight);
            console.log('devicePixelRatio:', dpr);
            console.log('Note: hairline sizes (0.5px) are usually rendered as 1 physical pixel on Retina.');

            // Clamp all active dots inside the new viewport
            for (const key in dots) {
                const dot = dots[key];
                if (!dot.active) continue;
                if (dot.x < 0) dot.x = 0;
                if (dot.y < 0) dot.y = 0;
                if (dot.x > viewportWidth) dot.x = viewportWidth;
                if (dot.y > viewportHeight) dot.y = viewportHeight;
            }

            // Keep frame and HUD visibility consistent with base state when not flashing
            if (!frameFlashActive) {
                applyBaseFrameVisibility();
            }

            // Log current state after resize (also refresh HUD text)
            logState();
        }

        // Toggle base frame visibility (Space)
        function toggleFrame() {
            frameBaseVisible = !frameBaseVisible;

            // If no flash is active, immediately reflect base visibility
            if (!frameFlashActive) {
                applyBaseFrameVisibility();
            }

            logState();
        }

        // Toggle a specific dot by key (1–4)
        function toggleDot(key) {
            const dot = dots[key];
            if (!dot) return;

            if (dot.active) {
                // Deactivate dot
                dot.active = false;
                dot.element.style.display = 'none';
            } else {
                // Activate dot: place in the center with random direction
                dot.active = true;
                dot.x = viewportWidth / 2;
                dot.y = viewportHeight / 2;

                const angle = Math.random() * Math.PI * 2;
                const speed = 0.75; // Movement speed in CSS pixels per frame (approx.)

                dot.vx = Math.cos(angle) * speed;
                dot.vy = Math.sin(angle) * speed;

                dot.element.style.display = 'block';
                dot.element.style.backgroundColor = dot.color;
            }

            logState();
        }

        // Flash the frame with the given color for a short time,
        // regardless of base visibility.
        function flashFrame(color) {
            frameFlashActive = true;
            frame.style.display = 'block';      // Ensure it is visible for the flash
            frame.style.borderColor = color;    // Set flash color

            // If HUD is visible (base frame is enabled), flash HUD text with the same color
            if (frameBaseVisible) {
                hud.style.color = color;
            }

            frameFlashEndTime = performance.now() + 80; // Flash duration in ms
            logState();
        }

        // Keyboard handler
        function handleKeyDown(event) {
            if (event.code === 'Space' || event.key === ' ') {
                // Toggle base frame visibility with Space
                event.preventDefault();
                toggleFrame();
                return;
            }

            // Number keys 1–4 to toggle dots
            if (event.key === '1' || event.key === '2' ||
                event.key === '3' || event.key === '4') {
                event.preventDefault();
                toggleDot(event.key);
            }
        }

        // Animation loop for moving dots and handling collisions
        function animate() {
            const now = performance.now();

            // Reset frame color after flash
            if (frameFlashActive && frameFlashEndTime > 0 && now > frameFlashEndTime) {
                frameFlashActive = false;
                frameFlashEndTime = 0;

                // Return to base frame and HUD state
                applyBaseFrameVisibility();
                hud.style.color = hudBaseColor; // Reset HUD text color to base
                logState();
            }

            for (const key in dots) {
                const dot = dots[key];
                if (!dot.active) continue;

                // Update position
                dot.x += dot.vx;
                dot.y += dot.vy;

                let hitWall = false;

                // Collision with left/right walls
                if (dot.x <= 0) {
                    dot.x = 0;
                    dot.vx = Math.abs(dot.vx);
                    hitWall = true;
                } else if (dot.x >= viewportWidth) {
                    dot.x = viewportWidth;
                    dot.vx = -Math.abs(dot.vx);
                    hitWall = true;
                }

                // Collision with top/bottom walls
                if (dot.y <= 0) {
                    dot.y = 0;
                    dot.vy = Math.abs(dot.vy);
                    hitWall = true;
                } else if (dot.y >= viewportHeight) {
                    dot.y = viewportHeight;
                    dot.vy = -Math.abs(dot.vy);
                    hitWall = true;
                }

                // If a wall was hit, flash the frame in this dot's color
                if (hitWall) {
                    flashFrame(dot.color);
                }

                // Apply position via CSS transform for subpixel precision
                dot.element.style.transform =
                    'translate(' + dot.x + 'px, ' + dot.y + 'px)';
            }

            requestAnimationFrame(animate);
        }

        // Event listeners
        window.addEventListener('resize', resizeToViewport);
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('load', function () {
            resizeToViewport();
            requestAnimationFrame(animate);
        });
        document.addEventListener('DOMContentLoaded', resizeToViewport);
    })();
</script>
</body>
</html>