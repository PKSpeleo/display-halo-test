<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Display Halo / Backlight Test (IPS / miniLED / OLED)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background: #000000; /* Absolutely black background for halo/blooming tests */
            overflow: hidden;    /* No scrollbars */
        }

        /* Fullscreen black wrapper – main test area for observing halos / local dimming behavior */
        #wrapper {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000; /* Absolutely black background */
            overflow: hidden;
            z-index: 0;
        }

        /* Frame drawn as a single border (under pixels), used to check uniformity near screen edges */
        #frame {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 1px solid #FFFFFF; /* Actual thickness is controlled via JS */
            box-sizing: border-box;
            background: transparent;
            display: none; /* Base visibility (toggled by Space key) */
            pointer-events: none;
            z-index: 1; /* Under pixels and explosions */
        }

        /* Moving pixel-like dots; actual size is controlled via JS.
           Used to observe local dimming, halos and blooming around small bright objects. */
        .pixel-dot {
            position: absolute;
            left: 0;
            top: 0;
            width: 1px;   /* Initial value, overridden by JS */
            height: 1px;  /* Initial value, overridden by JS */
            background-color: #FFFFFF;
            display: none;  /* Toggled by number keys 1–4, 5, 6 */
            pointer-events: none;
            z-index: 3; /* Above frame and push box, below HUD */
        }

        /* Explosion wave (square ring) – visualizes transient bright “flashes” to study halo behavior */
        .explosion {
            position: absolute;
            box-sizing: border-box;
            border-style: solid;
            background: transparent;
            pointer-events: none;
            z-index: 2; /* Under moving pixels, above frame */
        }

        /* Pointer-controlled square push box (100x100 physical px with inner rainbow frame).
           Used to "kick" pixels and observe halos while everything moves. */
        #pushBox {
            position: absolute;
            width: 0;
            height: 0;
            box-sizing: border-box;
            border-style: solid;
            border-color: #FFFFFF;
            background: transparent;
            pointer-events: none;
            display: none;
            z-index: 2; /* Under pixels, above frame */
        }

        /* HUD with state info in the bottom-right corner (visible only when base frame is enabled) */
        #hud {
            position: absolute;
            right: 8px;
            bottom: 8px;
            padding: 6px 8px;
            background: rgba(0, 0, 0, 0.6);
            color: #FFFFFF;
            font-family: monospace;
            font-size: 11px;
            line-height: 1.4;
            white-space: pre-wrap;
            pointer-events: none;
            display: none; /* Shown only when base frame is visible */
            text-align: right;
            max-width: 50%;
            z-index: 4; /* On top of everything */
        }
    </style>
</head>
<body>
<div id="wrapper">
    <!-- Pixel dots for keys 1–4 (base R/G/B/W test pixels) -->
    <div id="dot1" class="pixel-dot"></div> <!-- Red -->
    <div id="dot2" class="pixel-dot"></div> <!-- Green -->
    <div id="dot3" class="pixel-dot"></div> <!-- Blue -->
    <div id="dot4" class="pixel-dot"></div> <!-- White -->

    <!-- Frame with border that can blink on collisions with walls.
         Used to check edge behavior and blooming along the panel border. -->
    <div id="frame"></div>

    <!-- Dummy explosion element so the .explosion selector is statically “used”.
         Real explosion rings are created dynamically via JavaScript. -->
    <div class="explosion" style="display:none;"></div>

    <!-- Pointer-controlled square push box -->
    <div id="pushBox"></div>

    <!-- HUD with status info in the bottom-right corner -->
    <div id="hud"></div>
</div>

<script>
    (function () {
        // Main elements
        const wrapper = document.getElementById('wrapper');
        const frame = document.getElementById('frame');
        const hud = document.getElementById('hud');
        const pushBoxEl = document.getElementById('pushBox');

        // Dot configuration per key (single pixels 1–4)
        // These are primary test pixels for R/G/B/W halos on IPS / miniLED / OLED panels.
        const dotConfigs = {
            '1': { id: 'dot1', color: '#FF0000' }, // Red
            '2': { id: 'dot2', color: '#00FF00' }, // Green
            '3': { id: 'dot3', color: '#0000FF' }, // Blue (saturated)
            '4': { id: 'dot4', color: '#FFFFFF' }  // White
        };

        const SINGLE_KEYS = ['1', '2', '3', '4'];

        // Human-readable labels with colors (for HUD and console)
        const dotLabels = {
            '1': '1 (R)',
            '2': '2 (G)',
            '3': '3 (B)',
            '4': '4 (W)'
        };

        // Group "5" – vivid static colors to test multi-color halo behavior
        const COLOR_GROUP_LABEL_KEY = '5';
        const COLOR_GROUP_LABEL_TEXT = '5 (10 colour pixels)';
        const COLOR_GROUP_LABEL_COLOR = '#FF00FF'; // label color in HUD/console
        const COLOR_GROUP_COUNT = 10;

        // Group "6" – animated colors (slowly shifting hue to test gradients and local dimming)
        const ANIMATED_GROUP_LABEL_KEY = '6';
        const ANIMATED_GROUP_LABEL_TEXT = '6 (10 animated colours)';
        const ANIMATED_GROUP_LABEL_COLOR = '#FFA500'; // label color in HUD/console
        const ANIMATED_GROUP_COUNT = 10;

        // All dots (single + both groups) keyed by unique string
        const dots = {};

        // Dedicated storage for group-5 dots
        const colorGroupDots = [];
        let colorGroupActive = false; // toggled later

        // Dedicated storage for group-6 animated dots
        const animatedGroupDots = [];
        let animatedGroupActive = false; // toggled later

        // Explosions storage – transient square waves to observe blooming behavior
        const explosions = [];
        const EXPLOSION_DURATION = 1000; // ms

        // Viewport size in CSS pixels
        let viewportWidth = 0;
        let viewportHeight = 0;

        // devicePixelRatio-related sizing
        let currentDpr = window.devicePixelRatio || 1;
        let baseUnit = 1 / currentDpr;   // CSS px per "1 physical pixel" step

        // DEFAULT: equivalent to ~20 physical pixels (approx physical size for test objects)
        let pixelScale = 20;             // How many physical pixels thick (approx)
        const minScale = 1;              // No upper limit

        // Frame visibility and flashing
        let frameBaseVisible = false;       // Controlled by Space key
        const frameBaseColor = '#FFFFFF';
        const hudBaseColor = '#FFFFFF';
        let frameFlashEndTime = 0;          // Timestamp when flash should end
        let frameFlashActive = false;       // True while flash is active

        // Pointer-controlled square push box
        let pushBoxActive = false;
        let pushBoxX = 0;    // center X
        let pushBoxY = 0;    // center Y
        let prevPushBoxX = 0;
        let prevPushBoxY = 0;
        let pushBoxPointerId = null;
        const pushBoxSidePhysical = 100;   // side length in physical pixels
        const pushBoxBorderPhysical = 20;  // border thickness in physical pixels
        const pushBoxRestitution = 0.5;    // elasticity coefficient for collisions with push box
        let lastPushBoxVx = 0;             // last frame velocity in CSS px/frame
        let lastPushBoxVy = 0;
        let pushBoxHue = 0;                // hue for rainbow border [0..1]

        // Initialize single dots 1–4 (properties; positions are set later)
        for (const key in dotConfigs) {
            const cfg = dotConfigs[key];
            const el = document.getElementById(cfg.id);
            dots[key] = {
                key: key,
                element: el,
                color: cfg.color,
                active: false,
                x: 0,  // center x
                y: 0,  // center y
                vx: 0,
                vy: 0,
                groupKey: null,
                h: null,
                hSpeed: 0,
                captured: false,
                captureOffsetX: 0,
                captureOffsetY: 0
            };
        }

        // Convert HSV (0..1) to CSS rgb() string – used for vivid and animated colors
        function hsvToRgbCss(h, s, v) {
            let r, g, b;
            const i = Math.floor(h * 6);
            const f = h * 6 - i;
            const p = v * (1 - s);
            const q = v * (1 - f * s);
            const t = v * (1 - (1 - f) * s);

            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }

            const R = Math.round(r * 255);
            const G = Math.round(g * 255);
            const B = Math.round(b * 255);
            return 'rgb(' + R + ',' + G + ',' + B + ')';
        }

        // Build a vivid distinct palette of N colors (full saturation and value)
        // Used for static group-5 test pixels.
        function buildVividPalette(count) {
            const colors = [];
            for (let i = 0; i < count; i++) {
                const h = i / count;   // evenly spaced hue
                const s = 1.0;         // full saturation
                const v = 1.0;         // full brightness
                colors.push(hsvToRgbCss(h, s, v));
            }
            return colors;
        }

        // Parse CSS color to RGB object {r,g,b}
        function parseColorToRGB(color) {
            color = color.trim();
            if (color.startsWith('#')) {
                let r, g, b;
                if (color.length === 7) {
                    r = parseInt(color.slice(1, 3), 16);
                    g = parseInt(color.slice(3, 5), 16);
                    b = parseInt(color.slice(5, 7), 16);
                    return { r, g, b };
                } else if (color.length === 4) {
                    // #RGB shorthand
                    r = parseInt(color[1] + color[1], 16);
                    g = parseInt(color[2] + color[2], 16);
                    b = parseInt(color[3] + color[3], 16);
                    return { r, g, b };
                }
            } else if (color.startsWith('rgb')) {
                const inside = color.substring(color.indexOf('(') + 1, color.indexOf(')'));
                const parts = inside.split(',').map(v => parseInt(v.trim(), 10));
                if (parts.length >= 3) {
                    return { r: parts[0], g: parts[1], b: parts[2] };
                }
            }
            // Fallback: white
            return { r: 255, g: 255, b: 255 };
        }

        // Mix multiple CSS colors by averaging RGB – used for explosion wave color
        function mixColors(colors) {
            if (!colors.length) return 'rgb(255,255,255)';
            let sumR = 0, sumG = 0, sumB = 0;
            for (const c of colors) {
                const rgb = parseColorToRGB(c);
                sumR += rgb.r;
                sumG += rgb.g;
                sumB += rgb.b;
            }
            const n = colors.length;
            const r = Math.round(sumR / n);
            const g = Math.round(sumG / n);
            const b = Math.round(sumB / n);
            return 'rgb(' + r + ',' + g + ',' + b + ')';
        }

        // Create color group dots (for key 5) if not yet created
        function createColorGroupDotsIfNeeded() {
            if (colorGroupDots.length > 0) return;

            for (let i = 0; i < COLOR_GROUP_COUNT; i++) {
                const el = document.createElement('div');
                el.className = 'pixel-dot';
                wrapper.appendChild(el);

                const dotKey = '5_' + i;
                const dot = {
                    key: dotKey,
                    element: el,
                    color: '#FFFFFF', // will be overridden when group is activated
                    active: false,
                    x: 0,
                    y: 0,
                    vx: 0,
                    vy: 0,
                    groupKey: COLOR_GROUP_LABEL_KEY,
                    h: null,
                    hSpeed: 0,
                    captured: false,
                    captureOffsetX: 0,
                    captureOffsetY: 0
                };

                colorGroupDots.push(dot);
                dots[dotKey] = dot;
            }
        }

        // Create animated group dots (for key 6) if not yet created
        function createAnimatedGroupDotsIfNeeded() {
            if (animatedGroupDots.length > 0) return;

            for (let i = 0; i < ANIMATED_GROUP_COUNT; i++) {
                const el = document.createElement('div');
                el.className = 'pixel-dot';
                wrapper.appendChild(el);

                const dotKey = '6_' + i;
                const dot = {
                    key: dotKey,
                    element: el,
                    color: '#FFFFFF', // will be driven by HSV animation
                    active: false,
                    x: 0,
                    y: 0,
                    vx: 0,
                    vy: 0,
                    groupKey: ANIMATED_GROUP_LABEL_KEY,
                    h: 0,
                    hSpeed: 0,
                    captured: false,
                    captureOffsetX: 0,
                    captureOffsetY: 0
                };

                animatedGroupDots.push(dot);
                dots[dotKey] = dot;
            }
        }

        // Helper: current pixel size in CSS px (scaled by physical pixel ratio)
        function getPixelSizeCss() {
            return (1 / currentDpr) * pixelScale;
        }

        // Helper: push box side and border in CSS px (from physical units)
        function getPushBoxSideCss() {
            return pushBoxSidePhysical / currentDpr;
        }

        function getPushBoxBorderCss() {
            return pushBoxBorderPhysical / currentDpr;
        }

        // Randomize direction and set position to screen center
        // All pixels start from the center, then move in random directions.
        function randomizeDotPositionAndVelocity(dot) {
            dot.x = viewportWidth / 2;
            dot.y = viewportHeight / 2;

            // Random direction (angle) and fixed speed
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.75;
            dot.vx = Math.cos(angle) * speed;
            dot.vy = Math.sin(angle) * speed;
        }

        // Update CSS sizes for frame border, dot size and push box based on DPR and pixelScale
        function updatePixelSizes() {
            baseUnit = 1 / currentDpr;
            const sizeCss = getPixelSizeCss();

            // Frame border thickness corresponds to current pixel scale
            frame.style.borderWidth = sizeCss + 'px';

            for (const key in dots) {
                const dot = dots[key];
                dot.element.style.width = sizeCss + 'px';
                dot.element.style.height = sizeCss + 'px';
            }

            if (pushBoxActive) {
                const sideCss = getPushBoxSideCss();
                const borderCss = getPushBoxBorderCss();
                pushBoxEl.style.width = sideCss + 'px';
                pushBoxEl.style.height = sideCss + 'px';
                pushBoxEl.style.borderWidth = borderCss + 'px';
                pushBoxEl.style.transform =
                    'translate(' + (pushBoxX - sideCss / 2) + 'px, ' + (pushBoxY - sideCss / 2) + 'px)';
            }
        }

        // Log current state to the console and update HUD HTML (with colored pixel labels)
        function logState() {
            const sizeCss = getPixelSizeCss();
            const approxPhysical = pixelScale;

            // Active singles (1–4)
            const activeSingleKeys = [];
            for (const key of SINGLE_KEYS) {
                const dot = dots[key];
                if (dot && dot.active) {
                    activeSingleKeys.push(key);
                }
            }

            // Group 5 active?
            const group5Active =
                colorGroupActive && colorGroupDots.some(d => d.active);

            // Group 6 active?
            const group6Active =
                animatedGroupActive && animatedGroupDots.some(d => d.active);

            const activeLabelsForLine = [];
            activeSingleKeys.forEach(k => activeLabelsForLine.push(dotLabels[k] || k));
            if (group5Active) {
                activeLabelsForLine.push(COLOR_GROUP_LABEL_TEXT);
            }
            if (group6Active) {
                activeLabelsForLine.push(ANIMATED_GROUP_LABEL_TEXT);
            }

            const stateLines = [
                'Frame base visible: ' + frameBaseVisible,
                'Frame flash active: ' + frameFlashActive,
                'Push box active: ' + pushBoxActive,
                'Viewport: ' + viewportWidth + ' x ' + viewportHeight,
                'devicePixelRatio: ' + currentDpr,
                'Pixel scale: ' + pixelScale +
                ' (CSS px: ' + sizeCss.toFixed(3) +
                ', approx physical px: ' + approxPhysical + ')'
            ];

            console.log('--- STATE ---');
            stateLines.forEach(line => console.log(line));
            console.log(
                'Active pixels: ' +
                (activeLabelsForLine.length ? activeLabelsForLine.join(', ') : 'none')
            );

            // Colored console output with per-label color
            if (activeSingleKeys.length || group5Active || group6Active) {
                let line = 'Active pixels colored: ';
                const styles = [];
                let first = true;

                // Singles 1–4
                for (const key of activeSingleKeys) {
                    const label = dotLabels[key] || key;
                    line += (first ? '%c' : ', %c') + label;
                    styles.push('color: ' + dots[key].color + ';');
                    first = false;
                }

                // Group 5 label
                if (group5Active) {
                    line += (first ? '%c' : ', %c') + COLOR_GROUP_LABEL_TEXT;
                    styles.push('color: ' + COLOR_GROUP_LABEL_COLOR + ';');
                    first = false;
                }

                // Group 6 label
                if (group6Active) {
                    line += (first ? '%c' : ', %c') + ANIMATED_GROUP_LABEL_TEXT;
                    styles.push('color: ' + ANIMATED_GROUP_LABEL_COLOR + ';');
                }

                console.log(line, ...styles);
            } else {
                console.log('Active pixels colored: none');
            }

            console.log('---------------');

            // Build HUD HTML with colored pixel labels
            const hudLines = [];
            hudLines.push('Frame base visible: ' + frameBaseVisible);
            hudLines.push('Frame flash active: ' + frameFlashActive);
            hudLines.push('Push box active: ' + pushBoxActive);

            const hudParts = [];
            // Singles
            for (const key of activeSingleKeys) {
                const label = dotLabels[key] || key;
                const color = dots[key].color;
                hudParts.push(
                    '<span style="color:' + color + ';">' + label + '</span>'
                );
            }
            // Group 5
            if (group5Active) {
                hudParts.push(
                    '<span style="color:' + COLOR_GROUP_LABEL_COLOR + ';">' +
                    COLOR_GROUP_LABEL_TEXT +
                    '</span>'
                );
            }
            // Group 6
            if (group6Active) {
                hudParts.push(
                    '<span style="color:' + ANIMATED_GROUP_LABEL_COLOR + ';">' +
                    ANIMATED_GROUP_LABEL_TEXT +
                    '</span>'
                );
            }

            if (hudParts.length) {
                hudLines.push('Active pixels: ' + hudParts.join(', '));
            } else {
                hudLines.push('Active pixels: none');
            }

            hudLines.push('Viewport: ' + viewportWidth + ' x ' + viewportHeight);
            hudLines.push('devicePixelRatio: ' + currentDpr);
            hudLines.push(
                'Pixel scale: ' + pixelScale +
                ' (CSS px: ' + sizeCss.toFixed(3) +
                ', approx physical px: ' + approxPhysical + ')'
            );

            hud.innerHTML = hudLines.join('<br>');
        }

        // Apply base visibility to frame and HUD (only used when no flash is active)
        function applyBaseFrameVisibility() {
            if (frameBaseVisible) {
                frame.style.display = 'block';
                frame.style.borderColor = frameBaseColor;
                hud.style.display = 'block';
            } else {
                frame.style.display = 'none';
                frame.style.borderColor = frameBaseColor;
                hud.style.display = 'none';
            }
            if (!frameFlashActive) {
                hud.style.color = hudBaseColor;
            }
        }

        // Resize handler – tracks current viewport and recalculates constraints
        function resizeToViewport() {
            viewportWidth = window.innerWidth;
            viewportHeight = window.innerHeight;

            currentDpr = window.devicePixelRatio || 1;
            updatePixelSizes();

            wrapper.style.width = viewportWidth + 'px';
            wrapper.style.height = viewportHeight + 'px';

            console.clear();
            console.log('Viewport (window.innerWidth x window.innerHeight): ' +
                viewportWidth + ' x ' + viewportHeight);
            console.log('devicePixelRatio:', currentDpr);
            console.log('Note: border, pixel size and push box size are tied to devicePixelRatio.');

            // Clamp active dots to stay fully on screen
            const sizeCss = getPixelSizeCss();
            const half = sizeCss / 2;
            const minX = half;
            const maxX = viewportWidth - half;
            const minY = half;
            const maxY = viewportHeight - half;

            for (const key in dots) {
                const dot = dots[key];
                if (!dot.active) continue;
                if (dot.x < minX) dot.x = minX;
                if (dot.x > maxX) dot.x = maxX;
                if (dot.y < minY) dot.y = minY;
                if (dot.y > maxY) dot.y = maxY;
            }

            if (!frameFlashActive) {
                applyBaseFrameVisibility();
            }

            logState();
        }

        // Change pixel scale by delta (+1 or -1) and update sizes
        // Used to test halo behavior for different physical sizes of bright objects.
        function changePixelScale(delta) {
            const newScale = Math.max(minScale, pixelScale + delta); // no upper bound
            if (newScale === pixelScale) return;
            pixelScale = newScale;
            updatePixelSizes();

            // Re-clamp dots to keep them within screen edges
            const sizeCss = getPixelSizeCss();
            const half = sizeCss / 2;
            const minX = half;
            const maxX = viewportWidth - half;
            const minY = half;
            const maxY = viewportHeight - half;

            for (const key in dots) {
                const dot = dots[key];
                if (!dot.active) continue;
                if (dot.x < minX) dot.x = minX;
                if (dot.x > maxX) dot.x = maxX;
                if (dot.y < minY) dot.y = minY;
                if (dot.y > maxY) dot.y = maxY;
            }

            logState();
        }

        // Toggle base frame visibility (Space) – used to inspect edge glow/bleeding
        function toggleFrame() {
            frameBaseVisible = !frameBaseVisible;

            if (!frameFlashActive) {
                applyBaseFrameVisibility();
            }

            logState();
        }

        // Toggle a specific dot by key (1–4)
        function toggleDot(key) {
            const dot = dots[key];
            if (!dot) return;

            if (dot.active) {
                dot.active = false;
                dot.element.style.display = 'none';
            } else {
                dot.active = true;
                randomizeDotPositionAndVelocity(dot);
                dot.element.style.display = 'block';
                dot.element.style.backgroundColor = dot.color;
            }

            logState();
        }

        // Toggle group 5 (10 vivid colour pixels) – multi-color static halo test
        function toggleColorGroup() {
            createColorGroupDotsIfNeeded();
            updatePixelSizes();

            colorGroupActive = !colorGroupActive;

            if (colorGroupActive) {
                // Build vivid palette (all bright & distinct)
                const palette = buildVividPalette(COLOR_GROUP_COUNT);

                colorGroupDots.forEach((dot, index) => {
                    dot.active = true;
                    dot.color = palette[index % palette.length];
                    randomizeDotPositionAndVelocity(dot);
                    dot.element.style.display = 'block';
                    dot.element.style.backgroundColor = dot.color;
                });
            } else {
                // Deactivate group 5 pixels
                colorGroupDots.forEach(dot => {
                    dot.active = false;
                    dot.element.style.display = 'none';
                });
            }

            logState();
        }

        // Toggle group 6 (10 animated colour pixels) – gradient / animation halo test
        function toggleAnimatedGroup() {
            createAnimatedGroupDotsIfNeeded();
            updatePixelSizes();

            animatedGroupActive = !animatedGroupActive;

            if (animatedGroupActive) {
                animatedGroupDots.forEach(dot => {
                    dot.active = true;
                    dot.h = Math.random(); // random starting hue
                    dot.hSpeed = 0.0005 + Math.random() * 0.0015; // hue shift speed
                    dot.color = hsvToRgbCss(dot.h, 1.0, 1.0);
                    randomizeDotPositionAndVelocity(dot);
                    dot.element.style.display = 'block';
                    dot.element.style.backgroundColor = dot.color;
                });
            } else {
                // Deactivate group 6 pixels
                animatedGroupDots.forEach(dot => {
                    dot.active = false;
                    dot.element.style.display = 'none';
                });
            }

            logState();
        }

        // Flash the frame with the given color for a short time (wall collisions)
        // This lets you see how the panel handles sudden bright edges.
        function flashFrame(color) {
            frameFlashActive = true;
            frame.style.display = 'block';
            frame.style.borderColor = color;

            if (frameBaseVisible) {
                hud.style.color = color;
            }

            frameFlashEndTime = performance.now() + 80;
            logState();
        }

        // Create explosion at given center (cx, cy) with mixed color
        // Explosion is a square ring with thickness = current pixel scale
        // and radius up to 5 scales, lasting 1 second.
        function createExplosion(cx, cy, colors) {
            const explosionColor = mixColors(colors);
            const sizeCss = getPixelSizeCss();
            const maxRadius = sizeCss * 5;  // distance 5 scales (radius)

            const el = document.createElement('div');
            el.className = 'explosion';
            el.style.borderColor = explosionColor;
            el.style.opacity = '1';

            wrapper.appendChild(el);

            explosions.push({
                element: el,
                startTime: performance.now(),
                x: cx,
                y: cy,
                maxRadius: maxRadius
            });
        }

        // Keyboard handler (layout-independent for +/- using event.code)
        function handleKeyDown(event) {
            const code = event.code;

            // Space toggles frame
            if (code === 'Space') {
                event.preventDefault();
                toggleFrame();
                return;
            }

            // 1–4 by key value (number keys are stable enough)
            if (event.key === '1' || event.key === '2' ||
                event.key === '3' || event.key === '4') {
                event.preventDefault();
                toggleDot(event.key);
                return;
            }

            // 5 toggles group of 10 vivid colour pixels
            if (event.key === '5') {
                event.preventDefault();
                toggleColorGroup();
                return;
            }

            // 6 toggles group of 10 animated colour pixels
            if (event.key === '6') {
                event.preventDefault();
                toggleAnimatedGroup();
                return;
            }

            // Increase pixel scale:
            //   - 'Equal' -> physical key near Backspace (US: =/+)
            //   - 'NumpadAdd' -> plus on numpad
            if (code === 'Equal' || code === 'NumpadAdd') {
                event.preventDefault();
                changePixelScale(+1);
                return;
            }

            // Decrease pixel scale:
            //   - 'Minus' -> physical minus key near 0
            //   - 'NumpadSubtract' -> minus on numpad
            if (code === 'Minus' || code === 'NumpadSubtract') {
                event.preventDefault();
                changePixelScale(-1);
            }
        }

        // Capture all dots that are inside the push box at the moment of press
        function captureDotsInsidePushBox() {
            const sideCss = getPushBoxSideCss();
            const sizeCss = getPixelSizeCss();
            const halfDot = sizeCss / 2;
            const halfBox = sideCss / 2;
            const limitX = halfBox + halfDot;
            const limitY = halfBox + halfDot;

            for (const key in dots) {
                const dot = dots[key];
                if (!dot.active) continue;

                const dx = dot.x - pushBoxX;
                const dy = dot.y - pushBoxY;

                if (Math.abs(dx) <= limitX && Math.abs(dy) <= limitY) {
                    dot.captured = true;
                    dot.captureOffsetX = dx;
                    dot.captureOffsetY = dy;
                }
            }
        }

        // Pointer helpers (mouse/touch)
        function updatePushBoxFromEvent(event) {
            const rect = wrapper.getBoundingClientRect();
            pushBoxX = event.clientX - rect.left;
            pushBoxY = event.clientY - rect.top;
        }

        function handlePointerDown(event) {
            // Start tracking only primary pointer (to keep things simple on touch)
            if (pushBoxPointerId !== null) return;

            event.preventDefault();

            pushBoxPointerId = event.pointerId;
            updatePushBoxFromEvent(event);

            prevPushBoxX = pushBoxX;
            prevPushBoxY = pushBoxY;

            pushBoxActive = true;

            const sideCss = getPushBoxSideCss();
            const borderCss = getPushBoxBorderCss();
            pushBoxEl.style.width = sideCss + 'px';
            pushBoxEl.style.height = sideCss + 'px';
            pushBoxEl.style.borderWidth = borderCss + 'px';
            pushBoxEl.style.display = 'block';
            pushBoxEl.style.transform =
                'translate(' + (pushBoxX - sideCss / 2) + 'px, ' + (pushBoxY - sideCss / 2) + 'px)';

            // Capture pixels already inside the box
            captureDotsInsidePushBox();

            logState();
        }

        function handlePointerMove(event) {
            if (!pushBoxActive) return;
            if (event.pointerId !== pushBoxPointerId) return;

            event.preventDefault();
            updatePushBoxFromEvent(event);

            const sideCss = getPushBoxSideCss();
            pushBoxEl.style.transform =
                'translate(' + (pushBoxX - sideCss / 2) + 'px, ' + (pushBoxY - sideCss / 2) + 'px)';
        }

        function handlePointerUpOrCancel(event) {
            if (!pushBoxActive) return;
            if (event.pointerId !== pushBoxPointerId) return;

            event.preventDefault();

            pushBoxActive = false;
            pushBoxPointerId = null;
            pushBoxEl.style.display = 'none';

            // Release captured dots with velocity equal to the last push box velocity
            for (const key in dots) {
                const dot = dots[key];
                if (!dot.captured) continue;
                dot.captured = false;
                dot.vx = lastPushBoxVx;
                dot.vy = lastPushBoxVy;
            }

            logState();
        }

        // Animation loop: bounce from SCREEN EDGES, collide as squares, explosions, push-box interaction
        function animate() {
            const now = performance.now();

            // Frame flash timeout
            if (frameFlashActive && frameFlashEndTime > 0 && now > frameFlashEndTime) {
                frameFlashActive = false;
                frameFlashEndTime = 0;

                applyBaseFrameVisibility();
                hud.style.color = hudBaseColor;
                logState();
            }

            const sizeCss = getPixelSizeCss();
            const halfDot = sizeCss / 2;

            const minX = halfDot;                     // inner screen edge (left)
            const maxX = viewportWidth - halfDot;     // inner screen edge (right)
            const minY = halfDot;                     // inner screen edge (top)
            const maxY = viewportHeight - halfDot;    // inner screen edge (bottom)

            // Update push box velocity this frame (in CSS px per frame) and color
            let pushBoxVx = 0;
            let pushBoxVy = 0;
            let pushBoxColor = hsvToRgbCss(pushBoxHue, 1.0, 1.0);
            if (pushBoxActive) {
                pushBoxVx = pushBoxX - prevPushBoxX;
                pushBoxVy = pushBoxY - prevPushBoxY;
                prevPushBoxX = pushBoxX;
                prevPushBoxY = pushBoxY;

                lastPushBoxVx = pushBoxVx;
                lastPushBoxVy = pushBoxVy;

                const sideCss = getPushBoxSideCss();
                const borderCss = getPushBoxBorderCss();
                pushBoxEl.style.width = sideCss + 'px';
                pushBoxEl.style.height = sideCss + 'px';
                pushBoxEl.style.borderWidth = borderCss + 'px';
                pushBoxEl.style.transform =
                    'translate(' + (pushBoxX - sideCss / 2) + 'px, ' + (pushBoxY - sideCss / 2) + 'px)';
                pushBoxEl.style.borderColor = pushBoxColor;
            } else {
                lastPushBoxVx = 0;
                lastPushBoxVy = 0;
            }

            // Animate hue for the box border (rainbow effect)
            pushBoxHue += 0.003;
            if (pushBoxHue > 1) pushBoxHue -= 1;
            pushBoxColor = hsvToRgbCss(pushBoxHue, 1.0, 1.0);
            if (pushBoxActive) {
                pushBoxEl.style.borderColor = pushBoxColor;
            }

            const activeDots = [];

            // First pass: move dots, handle wall collisions, update animated colors
            for (const key in dots) {
                const dot = dots[key];
                if (!dot.active) continue;

                if (dot.captured && pushBoxActive) {
                    // Captured dots follow the box with their stored offset
                    dot.x = pushBoxX + dot.captureOffsetX;
                    dot.y = pushBoxY + dot.captureOffsetY;
                    activeDots.push(dot);
                    continue;
                }

                // If somehow captured but box is not active, drop capture state
                if (dot.captured && !pushBoxActive) {
                    dot.captured = false;
                }

                // Animated color update for group 6
                if (dot.groupKey === ANIMATED_GROUP_LABEL_KEY &&
                    typeof dot.h === 'number' &&
                    typeof dot.hSpeed === 'number') {
                    dot.h += dot.hSpeed;
                    if (dot.h > 1) dot.h -= 1;
                    const newColor = hsvToRgbCss(dot.h, 1.0, 1.0);
                    dot.color = newColor;
                    dot.element.style.backgroundColor = newColor;
                }

                dot.x += dot.vx;
                dot.y += dot.vy;

                let hitWall = false;

                // Bounce from screen edges
                if (dot.x <= minX) {
                    dot.x = minX;
                    dot.vx = Math.abs(dot.vx);
                    hitWall = true;
                } else if (dot.x >= maxX) {
                    dot.x = maxX;
                    dot.vx = -Math.abs(dot.vx);
                    hitWall = true;
                }

                if (dot.y <= minY) {
                    dot.y = minY;
                    dot.vy = Math.abs(dot.vy);
                    hitWall = true;
                } else if (dot.y >= maxY) {
                    dot.y = maxY;
                    dot.vy = -Math.abs(dot.vy);
                    hitWall = true;
                }

                if (hitWall) {
                    flashFrame(dot.color);
                }

                activeDots.push(dot);
            }

            // Second pass: handle collisions between dots as squares (AABB) + explosions
            for (let i = 0; i < activeDots.length; i++) {
                const a = activeDots[i];
                for (let j = i + 1; j < activeDots.length; j++) {
                    const b = activeDots[j];

                    const dx = b.x - a.x;
                    const dy = b.y - a.y;

                    // Check overlap of two squares (AABB in center-coordinates form)
                    if (Math.abs(dx) < sizeCss && Math.abs(dy) < sizeCss) {
                        // Compute overlap along each axis
                        const overlapX = sizeCss - Math.abs(dx);
                        const overlapY = sizeCss - Math.abs(dy);

                        // Approximate collision point as midpoint
                        const cx = (a.x + b.x) / 2;
                        const cy = (a.y + b.y) / 2;

                        // Create explosion with mixed color of both dots
                        createExplosion(cx, cy, [a.color, b.color]);

                        if (overlapX < overlapY) {
                            // Resolve along X axis
                            const correction = overlapX / 2;
                            if (dx > 0) {
                                // b is to the right of a
                                a.x -= correction;
                                b.x += correction;
                            } else {
                                // b is to the left of a
                                a.x += correction;
                                b.x -= correction;
                            }

                            // Elastic collision along X: swap vx
                            const tmpVx = a.vx;
                            a.vx = b.vx;
                            b.vx = tmpVx;
                        } else {
                            // Resolve along Y axis
                            const correction = overlapY / 2;
                            if (dy > 0) {
                                // b is below a
                                a.y -= correction;
                                b.y += correction;
                            } else {
                                // b is above a
                                a.y += correction;
                                b.y -= correction;
                            }

                            // Elastic collision along Y: swap vy
                            const tmpVy = a.vy;
                            a.vy = b.vy;
                            b.vy = tmpVy;
                        }

                        // Clamp back into screen bounds after correction
                        a.x = Math.max(minX, Math.min(maxX, a.x));
                        a.y = Math.max(minY, Math.min(maxY, a.y));
                        b.x = Math.max(minX, Math.min(maxX, b.x));
                        b.y = Math.max(minY, Math.min(maxY, b.y));
                    }
                }
            }

            // Third pass: interaction with push box as square (AABB) + explosions
            if (pushBoxActive) {
                const sideCss = getPushBoxSideCss();
                const halfBox = sideCss / 2;
                const halfDotSize = halfDot;

                for (const dot of activeDots) {
                    if (dot.captured) continue; // captured pixels just follow box

                    const dx = dot.x - pushBoxX;
                    const dy = dot.y - pushBoxY;

                    // Minkowski sum: check overlap between big box and dot square
                    const overlapX = (halfBox + halfDotSize) - Math.abs(dx);
                    const overlapY = (halfBox + halfDotSize) - Math.abs(dy);

                    if (overlapX > 0 && overlapY > 0) {
                        let cx, cy; // collision point on the box border
                        let nx = 0, ny = 0; // collision normal

                        if (overlapX < overlapY) {
                            // Collision with left/right side
                            if (dx > 0) {
                                // Right side
                                nx = 1;
                                cx = pushBoxX + halfBox;
                            } else {
                                // Left side
                                nx = -1;
                                cx = pushBoxX - halfBox;
                            }
                            cy = dot.y;
                        } else {
                            // Collision with top/bottom side
                            if (dy > 0) {
                                // Bottom
                                ny = 1;
                                cy = pushBoxY + halfBox;
                            } else {
                                // Top
                                ny = -1;
                                cy = pushBoxY - halfBox;
                            }
                            cx = dot.x;
                        }

                        // Explosion color mixes pixel color and current box border color
                        createExplosion(cx, cy, [dot.color, pushBoxColor]);

                        // Push dot out of the box along collision normal
                        if (nx !== 0) {
                            const correction = overlapX;
                            dot.x += nx * correction;
                        } else if (ny !== 0) {
                            const correction = overlapY;
                            dot.y += ny * correction;
                        }

                        // Reflect velocity relative to moving box along the normal with restitution
                        const relVx = dot.vx - pushBoxVx;
                        const relVy = dot.vy - pushBoxVy;
                        const relDot = relVx * nx + relVy * ny; // projection on normal

                        // v' = v - (1 + e) * (v·n) * n
                        const factor = (1 + pushBoxRestitution) * relDot;
                        const newRelVx = relVx - factor * nx;
                        const newRelVy = relVy - factor * ny;

                        dot.vx = newRelVx + pushBoxVx;
                        dot.vy = newRelVy + pushBoxVy;

                        // Clamp back into screen bounds after correction
                        dot.x = Math.max(minX, Math.min(maxX, dot.x));
                        dot.y = Math.max(minY, Math.min(maxY, dot.y));
                    }
                }
            }

            // Fourth pass: apply CSS transforms based on updated positions
            for (const dot of activeDots) {
                dot.element.style.transform =
                    'translate(' + (dot.x - halfDot) + 'px, ' + (dot.y - halfDot) + 'px)';
            }

            // Fifth pass: update explosions (square wave expanding over time)
            const toRemove = [];
            for (let i = 0; i < explosions.length; i++) {
                const ex = explosions[i];
                const life = now - ex.startTime;
                const t = life / EXPLOSION_DURATION;

                if (t >= 1) {
                    toRemove.push(i);
                    continue;
                }

                const radius = ex.maxRadius * t;      // 0 -> maxRadius over 1s
                const size = radius * 2;             // width/height
                const borderWidth = getPixelSizeCss(); // thickness according to scale
                const opacity = 1 - t;

                ex.element.style.width = size + 'px';
                ex.element.style.height = size + 'px';
                ex.element.style.borderWidth = borderWidth + 'px';
                ex.element.style.left = (ex.x - radius) + 'px';
                ex.element.style.top = (ex.y - radius) + 'px';
                ex.element.style.opacity = opacity.toString();
            }

            // Remove finished explosions (from end to start)
            for (let k = toRemove.length - 1; k >= 0; k--) {
                const idx = toRemove[k];
                const ex = explosions[idx];
                if (ex && ex.element && ex.element.parentNode) {
                    ex.element.parentNode.removeChild(ex.element);
                }
                explosions.splice(idx, 1);
            }

            requestAnimationFrame(animate);
        }

        // Event listeners
        window.addEventListener('resize', resizeToViewport);
        window.addEventListener('keydown', handleKeyDown);

        // Pointer events for mouse/touch
        wrapper.addEventListener('pointerdown', handlePointerDown);
        wrapper.addEventListener('pointermove', handlePointerMove);
        wrapper.addEventListener('pointerup', handlePointerUpOrCancel);
        wrapper.addEventListener('pointercancel', handlePointerUpOrCancel);
        wrapper.addEventListener('pointerleave', handlePointerUpOrCancel);

        window.addEventListener('load', function () {
            resizeToViewport();
            // Default behaviour: only mode 6 (animated colour pixels) is enabled
            toggleAnimatedGroup();
            requestAnimationFrame(animate);
        });
        document.addEventListener('DOMContentLoaded', resizeToViewport);
    })();
</script>
</body>
</html>