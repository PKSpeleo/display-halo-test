<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MacBook Pro 16 M3 Max – Retina Pixel Test</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background: #000000; /* Absolutely black background */
            overflow: hidden;    /* No scrollbars */
        }

        /* Fullscreen black wrapper */
        #wrapper {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000; /* Absolutely black background */
            overflow: hidden;
        }

        /* Frame exactly on screen edge; border width is controlled via JS */
        #frame {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 1px solid #FFFFFF; /* Initial value, overridden by JS */
            box-sizing: border-box;
            background: transparent;
            display: none; /* Base visibility (toggled by Space key) */
            pointer-events: none;
        }

        /* Moving pixel-like dots; actual size is controlled via JS */
        .pixel-dot {
            position: absolute;
            left: 0;
            top: 0;
            width: 1px;   /* Initial value, overridden by JS */
            height: 1px;  /* Initial value, overridden by JS */
            background-color: #FFFFFF;
            display: none;  /* Toggled by number keys 1–4 and 5-group */
            pointer-events: none;
        }

        /* HUD with state info in the bottom-right corner (visible only when base frame is enabled) */
        #hud {
            position: absolute;
            right: 8px;
            bottom: 8px;
            padding: 6px 8px;
            background: rgba(0, 0, 0, 0.6);
            color: #FFFFFF;
            font-family: monospace;
            font-size: 11px;
            line-height: 1.4;
            white-space: pre-wrap;
            pointer-events: none;
            display: none; /* Shown only when base frame is visible */
            text-align: right;
            max-width: 50%;
        }
    </style>
</head>
<body>
<div id="wrapper">
    <!-- Pixel dots for keys 1–4 -->
    <div id="dot1" class="pixel-dot"></div> <!-- Red -->
    <div id="dot2" class="pixel-dot"></div> <!-- Green -->
    <div id="dot3" class="pixel-dot"></div> <!-- Blue -->
    <div id="dot4" class="pixel-dot"></div> <!-- White -->

    <!-- Inner frame that can blink on collisions -->
    <div id="frame"></div>

    <!-- HUD with status info in the bottom-right corner -->
    <div id="hud"></div>
</div>

<script>
    (function () {
        const wrapper = document.getElementById('wrapper');
        const frame = document.getElementById('frame');
        const hud = document.getElementById('hud');

        // Dot configuration per key (single pixels 1–4)
        const dotConfigs = {
            '1': { id: 'dot1', color: '#FF0000' }, // Red
            '2': { id: 'dot2', color: '#00FF00' }, // Green
            '3': { id: 'dot3', color: '#0000FF' }, // Blue (saturated)
            '4': { id: 'dot4', color: '#FFFFFF' }  // White
        };

        const SINGLE_KEYS = ['1', '2', '3', '4'];

        // Human-readable labels with colors
        const dotLabels = {
            '1': '1 (R)',
            '2': '2 (G)',
            '3': '3 (B)',
            '4': '4 (W)'
        };

        // Group "5" label (10 colour pixels)
        const COLOR_GROUP_LABEL_KEY = '5';
        const COLOR_GROUP_LABEL_TEXT = '5 (10 colour pixels)';
        const COLOR_GROUP_LABEL_COLOR = '#FF00FF'; // label color in HUD/console

        const COLOR_GROUP_COUNT = 10;

        // All dots (single + group) keyed by unique string
        const dots = {};

        // Dedicated storage for group-5 dots
        const colorGroupDots = [];
        let colorGroupActive = false; // default off

        // Viewport size in CSS pixels
        let viewportWidth = 0;
        let viewportHeight = 0;

        // devicePixelRatio-related sizing
        let currentDpr = window.devicePixelRatio || 1;
        let baseUnit = 1 / currentDpr;   // CSS px per "1 physical pixel" step

        // DEFAULT: equivalent to ~20 physical pixels
        let pixelScale = 20;             // How many physical pixels thick (approx)
        const minScale = 1;              // No upper limit

        // Frame visibility and flashing
        let frameBaseVisible = false;       // Controlled by Space key
        const frameBaseColor = '#FFFFFF';
        const hudBaseColor = '#FFFFFF';
        let frameFlashEndTime = 0;          // Timestamp when flash should end
        let frameFlashActive = false;       // True while flash is active

        // Initialize single dots 1–4 (center-based coordinates)
        for (const key in dotConfigs) {
            const cfg = dotConfigs[key];
            const el = document.getElementById(cfg.id);
            dots[key] = {
                key: key,
                element: el,
                color: cfg.color,
                active: false,
                x: 0,  // center x
                y: 0,  // center y
                vx: 0,
                vy: 0,
                groupKey: null
            };
        }

        // hsv(0..1, 0..1, 0..1) -> 'rgb(r,g,b)'
        function hsvToRgbCss(h, s, v) {
            let r, g, b;
            const i = Math.floor(h * 6);
            const f = h * 6 - i;
            const p = v * (1 - s);
            const q = v * (1 - f * s);
            const t = v * (1 - (1 - f) * s);

            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }

            const R = Math.round(r * 255);
            const G = Math.round(g * 255);
            const B = Math.round(b * 255);
            return 'rgb(' + R + ',' + G + ',' + B + ')';
        }

        // Build a vivid distinct palette of N colors (full saturation and value)
        function buildVividPalette(count) {
            const colors = [];
            for (let i = 0; i < count; i++) {
                const h = i / count;   // evenly spaced hue
                const s = 1.0;         // full saturation
                const v = 1.0;         // full brightness
                colors.push(hsvToRgbCss(h, s, v));
            }
            return colors;
        }

        // Create color group dots (for key 5) if not yet created
        function createColorGroupDotsIfNeeded() {
            if (colorGroupDots.length > 0) return;

            for (let i = 0; i < COLOR_GROUP_COUNT; i++) {
                const el = document.createElement('div');
                el.className = 'pixel-dot';
                wrapper.appendChild(el);

                const dotKey = '5_' + i;
                const dot = {
                    key: dotKey,
                    element: el,
                    color: '#FFFFFF', // will be overridden when group is activated
                    active: false,
                    x: 0,
                    y: 0,
                    vx: 0,
                    vy: 0,
                    groupKey: COLOR_GROUP_LABEL_KEY
                };

                colorGroupDots.push(dot);
                dots[dotKey] = dot;
            }
        }

        // Helper: current pixel size in CSS px
        function getPixelSizeCss() {
            return (1 / currentDpr) * pixelScale;
        }

        // Update CSS sizes for frame border and dot size based on DPR and pixelScale
        function updatePixelSizes() {
            baseUnit = 1 / currentDpr;
            const sizeCss = getPixelSizeCss();

            frame.style.borderWidth = sizeCss + 'px';

            for (const key in dots) {
                const dot = dots[key];
                dot.element.style.width = sizeCss + 'px';
                dot.element.style.height = sizeCss + 'px';
            }
        }

        // Log current state to the console and update HUD HTML (with colored pixel labels)
        function logState() {
            const sizeCss = getPixelSizeCss();
            const approxPhysical = pixelScale;

            // Active singles (1–4)
            const activeSingleKeys = [];
            for (const key of SINGLE_KEYS) {
                const dot = dots[key];
                if (dot && dot.active) {
                    activeSingleKeys.push(key);
                }
            }

            // Group 5 active?
            const groupActive = colorGroupActive && colorGroupDots.some(d => d.active);

            const activeLabelsForLine = [];
            activeSingleKeys.forEach(k => activeLabelsForLine.push(dotLabels[k] || k));
            if (groupActive) {
                activeLabelsForLine.push(COLOR_GROUP_LABEL_TEXT);
            }

            const stateLines = [
                'Frame base visible: ' + frameBaseVisible,
                'Frame flash active: ' + frameFlashActive,
                'Viewport: ' + viewportWidth + ' x ' + viewportHeight,
                'devicePixelRatio: ' + currentDpr,
                'Pixel scale: ' + pixelScale +
                ' (CSS px: ' + sizeCss.toFixed(3) +
                ', approx physical px: ' + approxPhysical + ')'
            ];

            console.log('--- STATE ---');
            stateLines.forEach(line => console.log(line));
            console.log(
                'Active pixels: ' +
                (activeLabelsForLine.length ? activeLabelsForLine.join(', ') : 'none')
            );

            // Colored console output
            if (activeSingleKeys.length || groupActive) {
                let line = 'Active pixels colored: ';
                const styles = [];
                let first = true;

                // Singles 1–4
                for (const key of activeSingleKeys) {
                    const label = dotLabels[key] || key;
                    line += (first ? '%c' : ', %c') + label;
                    styles.push('color: ' + dots[key].color + ';');
                    first = false;
                }

                // Group 5 label
                if (groupActive) {
                    line += (first ? '%c' : ', %c') + COLOR_GROUP_LABEL_TEXT;
                    styles.push('color: ' + COLOR_GROUP_LABEL_COLOR + ';');
                }

                console.log(line, ...styles);
            } else {
                console.log('Active pixels colored: none');
            }

            console.log('---------------');

            // Build HUD HTML with colored pixel labels
            const hudLines = [];
            hudLines.push('Frame base visible: ' + frameBaseVisible);
            hudLines.push('Frame flash active: ' + frameFlashActive);

            const hudParts = [];
            // Singles
            for (const key of activeSingleKeys) {
                const label = dotLabels[key] || key;
                const color = dots[key].color;
                hudParts.push(
                    '<span style="color:' + color + ';">' + label + '</span>'
                );
            }
            // Group 5
            if (groupActive) {
                hudParts.push(
                    '<span style="color:' + COLOR_GROUP_LABEL_COLOR + ';">' +
                    COLOR_GROUP_LABEL_TEXT +
                    '</span>'
                );
            }

            if (hudParts.length) {
                hudLines.push('Active pixels: ' + hudParts.join(', '));
            } else {
                hudLines.push('Active pixels: none');
            }

            hudLines.push('Viewport: ' + viewportWidth + ' x ' + viewportHeight);
            hudLines.push('devicePixelRatio: ' + currentDpr);
            hudLines.push(
                'Pixel scale: ' + pixelScale +
                ' (CSS px: ' + sizeCss.toFixed(3) +
                ', approx physical px: ' + approxPhysical + ')'
            );

            hud.innerHTML = hudLines.join('<br>');
        }

        // Apply base visibility to frame and HUD (only used when no flash is active)
        function applyBaseFrameVisibility() {
            if (frameBaseVisible) {
                frame.style.display = 'block';
                frame.style.borderColor = frameBaseColor;
                hud.style.display = 'block';
            } else {
                frame.style.display = 'none';
                frame.style.borderColor = frameBaseColor;
                hud.style.display = 'none';
            }
            if (!frameFlashActive) {
                hud.style.color = hudBaseColor;
            }
        }

        function resizeToViewport() {
            viewportWidth = window.innerWidth;
            viewportHeight = window.innerHeight;

            currentDpr = window.devicePixelRatio || 1;
            updatePixelSizes();

            wrapper.style.width = viewportWidth + 'px';
            wrapper.style.height = viewportHeight + 'px';

            console.clear();
            console.log('Viewport (window.innerWidth x window.innerHeight): ' +
                viewportWidth + ' x ' + viewportHeight);
            console.log('devicePixelRatio:', currentDpr);
            console.log('Note: border and pixel size are tied to devicePixelRatio.');

            // Clamp active dots to stay fully on screen
            const sizeCss = getPixelSizeCss();
            const half = sizeCss / 2;
            const minX = half;
            const maxX = viewportWidth - half;
            const minY = half;
            const maxY = viewportHeight - half;

            for (const key in dots) {
                const dot = dots[key];
                if (!dot.active) continue;
                if (dot.x < minX) dot.x = minX;
                if (dot.x > maxX) dot.x = maxX;
                if (dot.y < minY) dot.y = minY;
                if (dot.y > maxY) dot.y = maxY;
            }

            if (!frameFlashActive) {
                applyBaseFrameVisibility();
            }

            logState();
        }

        // Change pixel scale by delta (+1 or -1) and update sizes
        function changePixelScale(delta) {
            const newScale = Math.max(minScale, pixelScale + delta); // no upper bound
            if (newScale === pixelScale) return;
            pixelScale = newScale;
            updatePixelSizes();

            // Re-clamp dots to keep them within screen edges
            const sizeCss = getPixelSizeCss();
            const half = sizeCss / 2;
            const minX = half;
            const maxX = viewportWidth - half;
            const minY = half;
            const maxY = viewportHeight - half;

            for (const key in dots) {
                const dot = dots[key];
                if (!dot.active) continue;
                if (dot.x < minX) dot.x = minX;
                if (dot.x > maxX) dot.x = maxX;
                if (dot.y < minY) dot.y = minY;
                if (dot.y > maxY) dot.y = maxY;
            }

            logState();
        }

        // Toggle base frame visibility (Space)
        function toggleFrame() {
            frameBaseVisible = !frameBaseVisible;

            if (!frameFlashActive) {
                applyBaseFrameVisibility();
            }

            logState();
        }

        // Toggle a specific dot by key (1–4)
        function toggleDot(key) {
            const dot = dots[key];
            if (!dot) return;

            if (dot.active) {
                dot.active = false;
                dot.element.style.display = 'none';
            } else {
                dot.active = true;
                dot.x = viewportWidth / 2;
                dot.y = viewportHeight / 2;

                const angle = Math.random() * Math.PI * 2;
                const speed = 0.75;

                dot.vx = Math.cos(angle) * speed;
                dot.vy = Math.sin(angle) * speed;

                dot.element.style.display = 'block';
                dot.element.style.backgroundColor = dot.color;
            }

            logState();
        }

        // Toggle group 5 (10 vivid colour pixels)
        function toggleColorGroup() {
            createColorGroupDotsIfNeeded();
            // Ensure new dots get current size immediately
            updatePixelSizes();

            colorGroupActive = !colorGroupActive;

            if (colorGroupActive) {
                // Build vivid palette (all bright & distinct)
                const palette = buildVividPalette(COLOR_GROUP_COUNT);

                const sizeCss = getPixelSizeCss();
                const half = sizeCss / 2;
                const minX = half;
                const maxX = viewportWidth - half;
                const minY = half;
                const maxY = viewportHeight - half;

                colorGroupDots.forEach((dot, index) => {
                    dot.active = true;
                    dot.color = palette[index % palette.length];
                    dot.x = Math.random() * (maxX - minX) + minX;
                    dot.y = Math.random() * (maxY - minY) + minY;

                    const angle = Math.random() * Math.PI * 2;
                    const speed = 0.75;
                    dot.vx = Math.cos(angle) * speed;
                    dot.vy = Math.sin(angle) * speed;

                    dot.element.style.display = 'block';
                    dot.element.style.backgroundColor = dot.color;
                });
            } else {
                // Deactivate group pixels
                colorGroupDots.forEach(dot => {
                    dot.active = false;
                    dot.element.style.display = 'none';
                });
            }

            logState();
        }

        // Flash the frame with the given color for a short time
        function flashFrame(color) {
            frameFlashActive = true;
            frame.style.display = 'block';
            frame.style.borderColor = color;

            if (frameBaseVisible) {
                hud.style.color = color;
            }

            frameFlashEndTime = performance.now() + 80;
            logState();
        }

        // Keyboard handler (layout-independent for +/- using event.code)
        function handleKeyDown(event) {
            const code = event.code;

            // Space toggles frame
            if (code === 'Space') {
                event.preventDefault();
                toggleFrame();
                return;
            }

            // 1–4 by key value (number keys are stable enough)
            if (event.key === '1' || event.key === '2' ||
                event.key === '3' || event.key === '4') {
                event.preventDefault();
                toggleDot(event.key);
                return;
            }

            // 5 toggles group of 10 vivid colour pixels
            if (event.key === '5') {
                event.preventDefault();
                toggleColorGroup();
                return;
            }

            // Increase pixel scale:
            //   - 'Equal' -> physical key near Backspace (US: =/+)
            //   - 'NumpadAdd' -> plus on numpad
            if (code === 'Equal' || code === 'NumpadAdd') {
                event.preventDefault();
                changePixelScale(+1);
                return;
            }

            // Decrease pixel scale:
            //   - 'Minus' -> physical minus key near 0
            //   - 'NumpadSubtract' -> minus on numpad
            if (code === 'Minus' || code === 'NumpadSubtract') {
                event.preventDefault();
                changePixelScale(-1);
                return;
            }
        }

        // Animation loop: bounce from SCREEN EDGES (not frame)
        function animate() {
            const now = performance.now();

            if (frameFlashActive && frameFlashEndTime > 0 && now > frameFlashEndTime) {
                frameFlashActive = false;
                frameFlashEndTime = 0;

                applyBaseFrameVisibility();
                hud.style.color = hudBaseColor;
                logState();
            }

            const sizeCss = getPixelSizeCss();
            const half = sizeCss / 2;

            const minX = half;                     // inner screen edge (left)
            const maxX = viewportWidth - half;     // inner screen edge (right)
            const minY = half;                     // inner screen edge (top)
            const maxY = viewportHeight - half;    // inner screen edge (bottom)

            for (const key in dots) {
                const dot = dots[key];
                if (!dot.active) continue;

                dot.x += dot.vx;
                dot.y += dot.vy;

                let hitWall = false;

                // Bounce from screen edges
                if (dot.x <= minX) {
                    dot.x = minX;
                    dot.vx = Math.abs(dot.vx);
                    hitWall = true;
                } else if (dot.x >= maxX) {
                    dot.x = maxX;
                    dot.vx = -Math.abs(dot.vx);
                    hitWall = true;
                }

                if (dot.y <= minY) {
                    dot.y = minY;
                    dot.vy = Math.abs(dot.vy);
                    hitWall = true;
                } else if (dot.y >= maxY) {
                    dot.y = maxY;
                    dot.vy = -Math.abs(dot.vy);
                    hitWall = true;
                }

                if (hitWall) {
                    flashFrame(dot.color);
                }

                // Translate from center coordinates to top-left for CSS positioning
                dot.element.style.transform =
                    'translate(' + (dot.x - half) + 'px, ' + (dot.y - half) + 'px)';
            }

            requestAnimationFrame(animate);
        }

        // Activate all single dots (1–4) by default at startup
        function activateDefaultDots() {
            for (const key of SINGLE_KEYS) {
                const dot = dots[key];
                if (!dot) continue;
                dot.active = true;
                dot.x = viewportWidth / 2;
                dot.y = viewportHeight / 2;
                const angle = Math.random() * Math.PI * 2;
                const speed = 0.75;
                dot.vx = Math.cos(angle) * speed;
                dot.vy = Math.sin(angle) * speed;
                dot.element.style.display = 'block';
                dot.element.style.backgroundColor = dot.color;
            }
            logState();
        }

        window.addEventListener('resize', resizeToViewport);
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('load', function () {
            resizeToViewport();
            activateDefaultDots();   // 1–4 ON by default
            requestAnimationFrame(animate);
        });
        document.addEventListener('DOMContentLoaded', resizeToViewport);
    })();
</script>
</body>
</html>