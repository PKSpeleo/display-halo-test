<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MacBook Pro 16 M3 Max – Retina Pixel Test</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background: #000000; /* Absolutely black background */
            overflow: hidden;    /* No scrollbars */
        }

        /* Fullscreen black wrapper */
        #wrapper {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000; /* Absolutely black background */
            overflow: hidden;
        }

        /* Frame exactly on screen edge; border width is controlled via JS */
        #frame {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 1px solid #FFFFFF; /* Initial value, overridden by JS */
            box-sizing: border-box;
            background: transparent;
            display: none; /* Base visibility (toggled by Space key) */
            pointer-events: none;
        }

        /* Moving pixel-like dots; actual size is controlled via JS */
        .pixel-dot {
            position: absolute;
            left: 0;
            top: 0;
            width: 1px;   /* Initial value, overridden by JS */
            height: 1px;  /* Initial value, overridden by JS */
            background-color: #FFFFFF;
            display: none;  /* Toggled by number keys 1–4 */
            pointer-events: none;
        }

        /* HUD with state info in the bottom-right corner (visible only when base frame is enabled) */
        #hud {
            position: absolute;
            right: 8px;
            bottom: 8px;
            padding: 6px 8px;
            background: rgba(0, 0, 0, 0.6);
            color: #FFFFFF;
            font-family: monospace;
            font-size: 11px;
            line-height: 1.4;
            white-space: pre-wrap;
            pointer-events: none;
            display: none; /* Shown only when base frame is visible */
            text-align: right;
            max-width: 50%;
        }
    </style>
</head>
<body>
<div id="wrapper">
    <!-- Pixel dots for keys 1–4 -->
    <div id="dot1" class="pixel-dot"></div> <!-- Red -->
    <div id="dot2" class="pixel-dot"></div> <!-- Green -->
    <div id="dot3" class="pixel-dot"></div> <!-- Cyan -->
    <div id="dot4" class="pixel-dot"></div> <!-- White -->

    <!-- Inner frame that can blink on collisions -->
    <div id="frame"></div>

    <!-- HUD with status info (bottom-right corner) -->
    <div id="hud"></div>
</div>

<script>
    (function () {
        const wrapper = document.getElementById('wrapper');
        const frame = document.getElementById('frame');
        const hud = document.getElementById('hud');

        // Dot configuration per key
        const dotConfigs = {
            '1': { id: 'dot1', color: '#FF0000' }, // Red
            '2': { id: 'dot2', color: '#00FF00' }, // Green
            '3': { id: 'dot3', color: '#00FFFF' }, // Cyan (Blue-like)
            '4': { id: 'dot4', color: '#FFFFFF' }  // White
        };

        // Human-readable labels with colors
        const dotLabels = {
            '1': '1 (R)',
            '2': '2 (G)',
            '3': '3 (B)',
            '4': '4 (W)'
        };

        // State for each dot (position, velocity, etc.)
        const dots = {};

        // Viewport size in CSS pixels
        let viewportWidth = 0;
        let viewportHeight = 0;

        // devicePixelRatio-related sizing
        let currentDpr = window.devicePixelRatio || 1;
        let baseUnit = 1 / currentDpr;   // CSS px per "1 physical pixel" step

        // DEFAULT: equivalent to ~20 physical pixels
        let pixelScale = 20;             // How many physical pixels thick (approx)
        const minScale = 1;              // No upper limit

        // Frame visibility and flashing
        let frameBaseVisible = false;       // Controlled by Space key
        const frameBaseColor = '#FFFFFF';
        const hudBaseColor = '#FFFFFF';
        let frameFlashEndTime = 0;          // Timestamp when flash should end
        let frameFlashActive = false;       // True while flash is active

        // Initialize dots map (center-based coordinates)
        for (const key in dotConfigs) {
            const cfg = dotConfigs[key];
            const el = document.getElementById(cfg.id);
            dots[key] = {
                key: key,
                element: el,
                color: cfg.color,
                active: false,
                x: 0,  // center x
                y: 0,  // center y
                vx: 0,
                vy: 0
            };
        }

        // Helper: current pixel size in CSS px
        function getPixelSizeCss() {
            return (1 / currentDpr) * pixelScale;
        }

        // Update CSS sizes for frame border and dot size based on DPR and pixelScale
        function updatePixelSizes() {
            baseUnit = 1 / currentDpr;
            const sizeCss = getPixelSizeCss();

            frame.style.borderWidth = sizeCss + 'px';

            for (const key in dots) {
                const dot = dots[key];
                dot.element.style.width = sizeCss + 'px';
                dot.element.style.height = sizeCss + 'px';
            }
        }

        // Log current state to the console and update HUD HTML (with colored pixel labels)
        function logState() {
            const activeKeys = [];
            for (const key in dots) {
                if (dots[key].active) {
                    activeKeys.push(key);
                }
            }

            const activeLabels = activeKeys.map(k => dotLabels[k] || k);

            const sizeCss = getPixelSizeCss();
            const approxPhysical = pixelScale;

            const stateLines = [
                'Frame base visible: ' + frameBaseVisible,
                'Frame flash active: ' + frameFlashActive,
                'Viewport: ' + viewportWidth + ' x ' + viewportHeight,
                'devicePixelRatio: ' + currentDpr,
                'Pixel scale: ' + pixelScale +
                ' (CSS px: ' + sizeCss.toFixed(3) +
                ', approx physical px: ' + approxPhysical + ')'
            ];

            console.log('--- STATE ---');
            stateLines.forEach(line => console.log(line));
            console.log(
                'Active pixels: ' +
                (activeLabels.length ? activeLabels.join(', ') : 'none')
            );

            if (activeKeys.length) {
                let line = 'Active pixels colored: ';
                const styles = [];
                activeKeys.forEach((k, index) => {
                    const label = dotLabels[k] || k;
                    line += (index === 0 ? '%c' : ', %c') + label;
                    styles.push('color: ' + dots[k].color + ';');
                });
                console.log(line, ...styles);
            } else {
                console.log('Active pixels colored: none');
            }

            console.log('---------------');

            // Build HUD HTML with colored pixel labels
            const hudLines = [];
            hudLines.push('Frame base visible: ' + frameBaseVisible);
            hudLines.push('Frame flash active: ' + frameFlashActive);

            if (activeKeys.length) {
                const coloredParts = activeKeys.map(k =>
                    '<span style="color:' + dots[k].color + ';">' +
                    (dotLabels[k] || k) +
                    '</span>'
                );
                hudLines.push('Active pixels: ' + coloredParts.join(', '));
            } else {
                hudLines.push('Active pixels: none');
            }

            hudLines.push('Viewport: ' + viewportWidth + ' x ' + viewportHeight);
            hudLines.push('devicePixelRatio: ' + currentDpr);
            hudLines.push(
                'Pixel scale: ' + pixelScale +
                ' (CSS px: ' + sizeCss.toFixed(3) +
                ', approx physical px: ' + approxPhysical + ')'
            );

            hud.innerHTML = hudLines.join('<br>');
        }

        // Apply base visibility to frame and HUD (only used when no flash is active)
        function applyBaseFrameVisibility() {
            if (frameBaseVisible) {
                frame.style.display = 'block';
                frame.style.borderColor = frameBaseColor;
                hud.style.display = 'block';
            } else {
                frame.style.display = 'none';
                frame.style.borderColor = frameBaseColor;
                hud.style.display = 'none';
            }
            if (!frameFlashActive) {
                hud.style.color = hudBaseColor;
            }
        }

        function resizeToViewport() {
            viewportWidth = window.innerWidth;
            viewportHeight = window.innerHeight;

            currentDpr = window.devicePixelRatio || 1;
            updatePixelSizes();

            wrapper.style.width = viewportWidth + 'px';
            wrapper.style.height = viewportHeight + 'px';

            console.clear();
            console.log('Viewport (window.innerWidth x window.innerHeight): ' +
                viewportWidth + ' x ' + viewportHeight);
            console.log('devicePixelRatio:', currentDpr);
            console.log('Note: border and pixel size are tied to devicePixelRatio.');

            // Clamp active dots to stay fully on screen
            const sizeCss = getPixelSizeCss();
            const half = sizeCss / 2;
            const minX = half;
            const maxX = viewportWidth - half;
            const minY = half;
            const maxY = viewportHeight - half;

            for (const key in dots) {
                const dot = dots[key];
                if (!dot.active) continue;
                if (dot.x < minX) dot.x = minX;
                if (dot.x > maxX) dot.x = maxX;
                if (dot.y < minY) dot.y = minY;
                if (dot.y > maxY) dot.y = maxY;
            }

            if (!frameFlashActive) {
                applyBaseFrameVisibility();
            }

            logState();
        }

        // Change pixel scale by delta (+1 or -1) and update sizes
        function changePixelScale(delta) {
            const newScale = Math.max(minScale, pixelScale + delta); // no upper bound
            if (newScale === pixelScale) return;
            pixelScale = newScale;
            updatePixelSizes();

            // Re-clamp dots to keep them within screen edges
            const sizeCss = getPixelSizeCss();
            const half = sizeCss / 2;
            const minX = half;
            const maxX = viewportWidth - half;
            const minY = half;
            const maxY = viewportHeight - half;

            for (const key in dots) {
                const dot = dots[key];
                if (!dot.active) continue;
                if (dot.x < minX) dot.x = minX;
                if (dot.x > maxX) dot.x = maxX;
                if (dot.y < minY) dot.y = minY;
                if (dot.y > maxY) dot.y = maxY;
            }

            logState();
        }

        // Toggle base frame visibility (Space)
        function toggleFrame() {
            frameBaseVisible = !frameBaseVisible;

            if (!frameFlashActive) {
                applyBaseFrameVisibility();
            }

            logState();
        }

        // Toggle a specific dot by key (1–4)
        function toggleDot(key) {
            const dot = dots[key];
            if (!dot) return;

            if (dot.active) {
                dot.active = false;
                dot.element.style.display = 'none';
            } else {
                dot.active = true;
                dot.x = viewportWidth / 2;
                dot.y = viewportHeight / 2;

                const angle = Math.random() * Math.PI * 2;
                const speed = 0.75;

                dot.vx = Math.cos(angle) * speed;
                dot.vy = Math.sin(angle) * speed;

                dot.element.style.display = 'block';
                dot.element.style.backgroundColor = dot.color;
            }

            logState();
        }

        // Flash the frame with the given color for a short time
        function flashFrame(color) {
            frameFlashActive = true;
            frame.style.display = 'block';
            frame.style.borderColor = color;

            if (frameBaseVisible) {
                hud.style.color = color;
            }

            frameFlashEndTime = performance.now() + 80;
            logState();
        }

        // Keyboard handler (layout-independent for +/- using event.code)
        function handleKeyDown(event) {
            const code = event.code;

            // Space toggles frame
            if (code === 'Space') {
                event.preventDefault();
                toggleFrame();
                return;
            }

            // 1–4 by key value (number keys are stable enough)
            if (event.key === '1' || event.key === '2' ||
                event.key === '3' || event.key === '4') {
                event.preventDefault();
                toggleDot(event.key);
                return;
            }

            // Increase pixel scale:
            //   - 'Equal' -> physical key near Backspace (US: =/+)
            //   - 'NumpadAdd' -> plus on numpad
            if (code === 'Equal' || code === 'NumpadAdd') {
                event.preventDefault();
                changePixelScale(+1);
                return;
            }

            // Decrease pixel scale:
            //   - 'Minus' -> physical minus key near 0
            //   - 'NumpadSubtract' -> minus on numpad
            if (code === 'Minus' || code === 'NumpadSubtract') {
                event.preventDefault();
                changePixelScale(-1);
                return;
            }
        }

        // Animation loop: bounce from SCREEN EDGES (not frame)
        function animate() {
            const now = performance.now();

            if (frameFlashActive && frameFlashEndTime > 0 && now > frameFlashEndTime) {
                frameFlashActive = false;
                frameFlashEndTime = 0;

                applyBaseFrameVisibility();
                hud.style.color = hudBaseColor;
                logState();
            }

            const sizeCss = getPixelSizeCss();
            const half = sizeCss / 2;

            const minX = half;                     // inner screen edge (left)
            const maxX = viewportWidth - half;     // inner screen edge (right)
            const minY = half;                     // inner screen edge (top)
            const maxY = viewportHeight - half;    // inner screen edge (bottom)

            for (const key in dots) {
                const dot = dots[key];
                if (!dot.active) continue;

                dot.x += dot.vx;
                dot.y += dot.vy;

                let hitWall = false;

                // Bounce from screen edges (independent of frame border width)
                if (dot.x <= minX) {
                    dot.x = minX;
                    dot.vx = Math.abs(dot.vx);
                    hitWall = true;
                } else if (dot.x >= maxX) {
                    dot.x = maxX;
                    dot.vx = -Math.abs(dot.vx);
                    hitWall = true;
                }

                if (dot.y <= minY) {
                    dot.y = minY;
                    dot.vy = Math.abs(dot.vy);
                    hitWall = true;
                } else if (dot.y >= maxY) {
                    dot.y = maxY;
                    dot.vy = -Math.abs(dot.vy);
                    hitWall = true;
                }

                if (hitWall) {
                    flashFrame(dot.color);
                }

                // Translate from center coordinates to top-left for CSS positioning
                dot.element.style.transform =
                    'translate(' + (dot.x - half) + 'px, ' + (dot.y - half) + 'px)';
            }

            requestAnimationFrame(animate);
        }

        // Activate all dots by default at startup
        function activateDefaultDots() {
            for (const key of ['1', '2', '3', '4']) {
                const dot = dots[key];
                if (!dot) continue;
                dot.active = true;
                dot.x = viewportWidth / 2;
                dot.y = viewportHeight / 2;
                const angle = Math.random() * Math.PI * 2;
                const speed = 0.75;
                dot.vx = Math.cos(angle) * speed;
                dot.vy = Math.sin(angle) * speed;
                dot.element.style.display = 'block';
                dot.element.style.backgroundColor = dot.color;
            }
            logState();
        }

        window.addEventListener('resize', resizeToViewport);
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('load', function () {
            resizeToViewport();
            activateDefaultDots();
            requestAnimationFrame(animate);
        });
        document.addEventListener('DOMContentLoaded', resizeToViewport);
    })();
</script>
</body>
</html>