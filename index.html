<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Display Halo / Backlight Test (IPS / miniLED / OLED)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background: #000000; /* Absolutely black background for halo/blooming tests */
            overflow: hidden;    /* No scrollbars */
            touch-action: none;  /* Disable browser scrolling/zooming to keep pointer events stable */
        }

        /* Fullscreen black wrapper – main test area for observing halos / local dimming behavior */
        #wrapper {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000; /* Absolutely black background */
            overflow: hidden;
            z-index: 0;
            touch-action: none;  /* Important for mobile: keep pointer events, do not scroll */
        }

        /* Frame drawn as a single border (under pixels), used to check uniformity near screen edges */
        #frame {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 1px solid #FFFFFF; /* Actual thickness is controlled via JS */
            box-sizing: border-box;
            background: transparent;
            display: none; /* Base visibility (toggled by Space key) */
            pointer-events: none;
            z-index: 1; /* Under pixels and explosions */
        }

        /* Moving pixel-like dots; actual size is controlled via JS.
           Used to observe local dimming, halos and blooming around small bright objects. */
        .pixel-dot {
            position: absolute;
            left: 0;
            top: 0;
            width: 1px;   /* Initial value, overridden by JS */
            height: 1px;  /* Initial value, overridden by JS */
            background-color: #FFFFFF;
            display: none;  /* Toggled by number keys 1–4, 5, 6 */
            pointer-events: none;
            z-index: 3; /* Above frame and push boxes, below HUD */
        }

        /* Explosion wave (square ring) – visualizes transient bright “flashes” to study halo behavior */
        .explosion {
            position: absolute;
            box-sizing: border-box;
            border-style: solid;
            background: transparent;
            pointer-events: none;
            z-index: 2; /* Under moving pixels, above frame */
        }

        /* Pointer-controlled square push boxes (300x300 physical px with rainbow frame).
           Used to "kick" pixels and observe halos while everything moves. */
        .pushBox {
            position: absolute;
            width: 0;
            height: 0;
            box-sizing: border-box;
            border-style: solid;
            border-color: #FFFFFF;
            background: transparent;
            pointer-events: none;
            display: none;
            z-index: 2; /* Under pixels, above frame */
        }

        /* HUD with state info in the bottom-right corner (visible only when base frame is enabled) */
        #hud {
            position: absolute;
            right: 8px;
            bottom: 8px;
            padding: 6px 8px;
            background: rgba(0, 0, 0, 0.6);
            color: #FFFFFF;
            font-family: monospace;
            font-size: 11px;
            line-height: 1.4;
            white-space: pre-wrap;
            pointer-events: none;
            display: none; /* Shown only when base frame is visible */
            text-align: right;
            max-width: 50%;
            z-index: 4; /* On top of everything */
        }
    </style>
</head>
<body>
<div id="wrapper">
    <!-- Pixel dots for keys 1–4 (base R/G/B/W test pixels) -->
    <div id="dot1" class="pixel-dot"></div> <!-- Red -->
    <div id="dot2" class="pixel-dot"></div> <!-- Green -->
    <div id="dot3" class="pixel-dot"></div> <!-- Blue -->
    <div id="dot4" class="pixel-dot"></div> <!-- White -->

    <!-- Frame with border that can blink on collisions with walls.
         Used to check edge behavior and blooming along the panel border. -->
    <div id="frame"></div>

    <!-- Dummy explosion element so the .explosion selector is statically “used”.
         Real explosion rings are created dynamically via JavaScript. -->
    <div class="explosion" style="display:none;"></div>

    <!-- Dummy pushBox so the .pushBox selector is statically “used”.
         Real push boxes are created dynamically via JavaScript for each pointer. -->
    <div class="pushBox" style="display:none;"></div>

    <!-- HUD with status info in the bottom-right corner -->
    <div id="hud"></div>
</div>

<script>
    (function () {
        // Main elements
        const wrapper = document.getElementById('wrapper');
        const frame = document.getElementById('frame');
        const hud = document.getElementById('hud');

        // Dot configuration per key (single pixels 1–4)
        // These are primary test pixels for R/G/B/W halos on IPS / miniLED / OLED panels.
        const dotConfigs = {
            '1': { id: 'dot1', color: '#FF0000' }, // Red
            '2': { id: 'dot2', color: '#00FF00' }, // Green
            '3': { id: 'dot3', color: '#0000FF' }, // Blue (saturated)
            '4': { id: 'dot4', color: '#FFFFFF' }  // White
        };

        const SINGLE_KEYS = ['1', '2', '3', '4'];

        // Human-readable labels with colors (for HUD and console)
        const dotLabels = {
            '1': '1 (R)',
            '2': '2 (G)',
            '3': '3 (B)',
            '4': '4 (W)'
        };

        // Group "5" – vivid static colors to test multi-color halo behavior
        const COLOR_GROUP_LABEL_KEY = '5';
        const COLOR_GROUP_LABEL_TEXT = '5 (10 colour pixels)';
        const COLOR_GROUP_LABEL_COLOR = '#FF00FF'; // label color in HUD/console
        const COLOR_GROUP_COUNT = 10;

        // Group "6" – animated colors (slowly shifting hue to test gradients and local dimming)
        const ANIMATED_GROUP_LABEL_KEY = '6';
        const ANIMATED_GROUP_LABEL_TEXT = '6 (10 animated colours)';
        const ANIMATED_GROUP_LABEL_COLOR = '#FFA500'; // label color in HUD/console
        const ANIMATED_GROUP_COUNT = 10;

        // All dots (single + both groups) keyed by unique string
        const dots = {};

        // Dedicated storage for group-5 dots
        const colorGroupDots = [];
        let colorGroupActive = false; // toggled later

        // Dedicated storage for group-6 animated dots
        const animatedGroupDots = [];
        let animatedGroupActive = false; // toggled later

        // Explosions storage – transient square waves to observe blooming behavior
        const explosions = [];
        const EXPLOSION_DURATION = 1000; // ms

        // Viewport size in CSS pixels
        let viewportWidth = 0;
        let viewportHeight = 0;

        // devicePixelRatio-related sizing
        let currentDpr = window.devicePixelRatio || 1;
        let baseUnit = 1 / currentDpr;   // CSS px per "1 physical pixel" step

        // DEFAULT: equivalent to ~20 physical pixels (approx physical size for test objects)
        let pixelScale = 20;             // How many physical pixels thick (approx)
        const minScale = 1;              // No upper limit

        // Frame visibility and flashing
        let frameBaseVisible = false;       // Controlled by Space key
        const frameBaseColor = '#FFFFFF';
        const hudBaseColor = '#FFFFFF';
        let frameFlashEndTime = 0;          // Timestamp when flash should end
        let frameFlashActive = false;       // True while flash is active

        // Pointer-controlled square push boxes (one per active pointer)
        const pushBoxes = {}; // pointerId -> {pointerId, el, x,y,prevX,prevY,lastVx,lastVy,hue,color}
        const pushBoxSidePhysical = 300;   // side length in physical pixels (300x300)
        const pushBoxBorderPhysical = 20;  // border thickness in physical pixels
        const pushBoxRestitution = 0.5;    // elasticity coefficient for collisions

        // Initialize single dots 1–4 (properties; positions are set later)
        for (const key in dotConfigs) {
            const cfg = dotConfigs[key];
            const el = document.getElementById(cfg.id);
            dots[key] = {
                key: key,
                element: el,
                color: cfg.color,
                active: false,
                x: 0,  // center x
                y: 0,  // center y
                vx: 0,
                vy: 0,
                groupKey: null,
                h: null,
                hSpeed: 0,
                captured: false,
                capturedBy: null,
                captureOffsetX: 0,
                captureOffsetY: 0
            };
        }

        // Convert HSV (0..1) to CSS rgb() string – used for vivid and animated colors
        function hsvToRgbCss(h, s, v) {
            let r, g, b;
            const i = Math.floor(h * 6);
            const f = h * 6 - i;
            const p = v * (1 - s);
            const q = v * (1 - f * s);
            const t = v * (1 - (1 - f) * s);

            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }

            const R = Math.round(r * 255);
            const G = Math.round(g * 255);
            const B = Math.round(b * 255);
            return 'rgb(' + R + ',' + G + ',' + B + ')';
        }

        // Build a vivid distinct palette of N colors (full saturation and value)
        // Used for static group-5 test pixels.
        function buildVividPalette(count) {
            const colors = [];
            for (let i = 0; i < count; i++) {
                const h = i / count;   // evenly spaced hue
                const s = 1.0;         // full saturation
                const v = 1.0;         // full brightness
                colors.push(hsvToRgbCss(h, s, v));
            }
            return colors;
        }

        // Parse CSS color to RGB object {r,g,b}
        function parseColorToRGB(color) {
            color = color.trim();
            if (color.startsWith('#')) {
                let r, g, b;
                if (color.length === 7) {
                    r = parseInt(color.slice(1, 3), 16);
                    g = parseInt(color.slice(3, 5), 16);
                    b = parseInt(color.slice(5, 7), 16);
                    return { r, g, b };
                } else if (color.length === 4) {
                    // #RGB shorthand
                    r = parseInt(color[1] + color[1], 16);
                    g = parseInt(color[2] + color[2], 16);
                    b = parseInt(color[3] + color[3], 16);
                    return { r, g, b };
                }
            } else if (color.startsWith('rgb')) {
                const inside = color.substring(color.indexOf('(') + 1, color.indexOf(')'));
                const parts = inside.split(',').map(v => parseInt(v.trim(), 10));
                if (parts.length >= 3) {
                    return { r: parts[0], g: parts[1], b: parts[2] };
                }
            }
            // Fallback: white
            return { r: 255, g: 255, b: 255 };
        }

        // Mix multiple CSS colors by averaging RGB – used for explosion wave color
        function mixColors(colors) {
            if (!colors.length) return 'rgb(255,255,255)';
            let sumR = 0, sumG = 0, sumB = 0;
            for (const c of colors) {
                const rgb = parseColorToRGB(c);
                sumR += rgb.r;
                sumG += rgb.g;
                sumB += rgb.b;
            }
            const n = colors.length;
            const r = Math.round(sumR / n);
            const g = Math.round(sumG / n);
            const b = Math.round(sumB / n);
            return 'rgb(' + r + ',' + g + ',' + b + ')';
        }

        // Create color group dots (for key 5) if not yet created
        function createColorGroupDotsIfNeeded() {
            if (colorGroupDots.length > 0) return;

            for (let i = 0; i < COLOR_GROUP_COUNT; i++) {
                const el = document.createElement('div');
                el.className = 'pixel-dot';
                wrapper.appendChild(el);

                const dotKey = '5_' + i;
                const dot = {
                    key: dotKey,
                    element: el,
                    color: '#FFFFFF', // will be overridden when group is activated
                    active: false,
                    x: 0,
                    y: 0,
                    vx: 0,
                    vy: 0,
                    groupKey: COLOR_GROUP_LABEL_KEY,
                    h: null,
                    hSpeed: 0,
                    captured: false,
                    capturedBy: null,
                    captureOffsetX: 0,
                    captureOffsetY: 0
                };

                colorGroupDots.push(dot);
                dots[dotKey] = dot;
            }
        }

        // Create animated group dots (for key 6) if not yet created
        function createAnimatedGroupDotsIfNeeded() {
            if (animatedGroupDots.length > 0) return;

            for (let i = 0; i < ANIMATED_GROUP_COUNT; i++) {
                const el = document.createElement('div');
                el.className = 'pixel-dot';
                wrapper.appendChild(el);

                const dotKey = '6_' + i;
                const dot = {
                    key: dotKey,
                    element: el,
                    color: '#FFFFFF', // will be driven by HSV animation
                    active: false,
                    x: 0,
                    y: 0,
                    vx: 0,
                    vy: 0,
                    groupKey: ANIMATED_GROUP_LABEL_KEY,
                    h: 0,
                    hSpeed: 0,
                    captured: false,
                    capturedBy: null,
                    captureOffsetX: 0,
                    captureOffsetY: 0
                };

                animatedGroupDots.push(dot);
                dots[dotKey] = dot;
            }
        }

        // Helper: current pixel size in CSS px (scaled by physical pixel ratio)
        function getPixelSizeCss() {
            return (1 / currentDpr) * pixelScale;
        }

        // Helper: push box side and border in CSS px (from physical units)
        function getPushBoxSideCss() {
            return pushBoxSidePhysical / currentDpr;
        }

        function getPushBoxBorderCss() {
            return pushBoxBorderPhysical / currentDpr;
        }

        // Randomize direction and set position to screen center
        // All pixels start from the center, then move in random directions.
        function randomizeDotPositionAndVelocity(dot) {
            dot.x = viewportWidth / 2;
            dot.y = viewportHeight / 2;

            // Random direction (angle) and fixed speed
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.75;
            dot.vx = Math.cos(angle) * speed;
            dot.vy = Math.sin(angle) * speed;
        }

        // Update CSS sizes for frame border and dot size based on DPR and pixelScale
        function updatePixelSizes() {
            baseUnit = 1 / currentDpr;
            const sizeCss = getPixelSizeCss();

            // Frame border thickness corresponds to current pixel scale
            frame.style.borderWidth = sizeCss + 'px';

            for (const key in dots) {
                const dot = dots[key];
                dot.element.style.width = sizeCss + 'px';
                dot.element.style.height = sizeCss + 'px';
            }
        }

        // Log current state to the console and update HUD HTML (with colored pixel labels)
        function logState() {
            const sizeCss = getPixelSizeCss();
            const approxPhysical = pixelScale;

            // Active singles (1–4)
            const activeSingleKeys = [];
            for (const key of SINGLE_KEYS) {
                const dot = dots[key];
                if (dot && dot.active) {
                    activeSingleKeys.push(key);
                }
            }

            // Group 5 active?
            const group5Active =
                colorGroupActive && colorGroupDots.some(d => d.active);

            // Group 6 active?
            const group6Active =
                animatedGroupActive && animatedGroupDots.some(d => d.active);

            const activeLabelsForLine = [];
            activeSingleKeys.forEach(k => activeLabelsForLine.push(dotLabels[k] || k));
            if (group5Active) {
                activeLabelsForLine.push(COLOR_GROUP_LABEL_TEXT);
            }
            if (group6Active) {
                activeLabelsForLine.push(ANIMATED_GROUP_LABEL_TEXT);
            }

            const activeBoxIds = Object.keys(pushBoxes);
            const activeBoxCount = activeBoxIds.length;

            const stateLines = [
                'Frame base visible: ' + frameBaseVisible,
                'Frame flash active: ' + frameFlashActive,
                'Active push boxes: ' + activeBoxCount,
                'Viewport: ' + viewportWidth + ' x ' + viewportHeight,
                'devicePixelRatio: ' + currentDpr,
                'Pixel scale: ' + pixelScale +
                ' (CSS px: ' + sizeCss.toFixed(3) +
                ', approx physical px: ' + approxPhysical + ')'
            ];

            console.log('--- STATE ---');
            stateLines.forEach(line => console.log(line));
            console.log(
                'Active pixels: ' +
                (activeLabelsForLine.length ? activeLabelsForLine.join(', ') : 'none')
            );

            // Colored console output with per-label color
            if (activeSingleKeys.length || group5Active || group6Active) {
                let line = 'Active pixels colored: ';
                const styles = [];
                let first = true;

                // Singles 1–4
                for (const key of activeSingleKeys) {
                    const label = dotLabels[key] || key;
                    line += (first ? '%c' : ', %c') + label;
                    styles.push('color: ' + dots[key].color + ';');
                    first = false;
                }

                // Group 5 label
                if (group5Active) {
                    line += (first ? '%c' : ', %c') + COLOR_GROUP_LABEL_TEXT;
                    styles.push('color: ' + COLOR_GROUP_LABEL_COLOR + ';');
                    first = false;
                }

                // Group 6 label
                if (group6Active) {
                    line += (first ? '%c' : ', %c') + ANIMATED_GROUP_LABEL_TEXT;
                    styles.push('color: ' + ANIMATED_GROUP_LABEL_COLOR + ';');
                }

                console.log(line, ...styles);
            } else {
                console.log('Active pixels colored: none');
            }

            console.log('---------------');

            // Build HUD HTML with colored pixel labels
            const hudLines = [];
            hudLines.push('Frame base visible: ' + frameBaseVisible);
            hudLines.push('Frame flash active: ' + frameFlashActive);
            hudLines.push('Active push boxes: ' + activeBoxCount);

            const hudParts = [];
            // Singles
            for (const key of activeSingleKeys) {
                const label = dotLabels[key] || key;
                const color = dots[key].color;
                hudParts.push(
                    '<span style="color:' + color + ';">' + label + '</span>'
                );
            }
            // Group 5
            if (group5Active) {
                hudParts.push(
                    '<span style="color:' + COLOR_GROUP_LABEL_COLOR + ';">' +
                    COLOR_GROUP_LABEL_TEXT +
                    '</span>'
                );
            }
            // Group 6
            if (group6Active) {
                hudParts.push(
                    '<span style="color:' + ANIMATED_GROUP_LABEL_COLOR + ';">' +
                    ANIMATED_GROUP_LABEL_TEXT +
                    '</span>'
                );
            }

            if (hudParts.length) {
                hudLines.push('Active pixels: ' + hudParts.join(', '));
            } else {
                hudLines.push('Active pixels: none');
            }

            hudLines.push('Viewport: ' + viewportWidth + ' x ' + viewportHeight);
            hudLines.push('devicePixelRatio: ' + currentDpr);
            hudLines.push(
                'Pixel scale: ' + pixelScale +
                ' (CSS px: ' + sizeCss.toFixed(3) +
                ', approx physical px: ' + approxPhysical + ')'
            );

            hud.innerHTML = hudLines.join('<br>');
        }

        // Apply base visibility to frame and HUD (only used when no flash is active)
        function applyBaseFrameVisibility() {
            if (frameBaseVisible) {
                frame.style.display = 'block';
                frame.style.borderColor = frameBaseColor;
                hud.style.display = 'block';
            } else {
                frame.style.display = 'none';
                frame.style.borderColor = frameBaseColor;
                hud.style.display = 'none';
            }
            if (!frameFlashActive) {
                hud.style.color = hudBaseColor;
            }
        }

        // Resize handler – tracks current viewport and recalculates constraints
        function resizeToViewport() {
            viewportWidth = window.innerWidth;
            viewportHeight = window.innerHeight;

            currentDpr = window.devicePixelRatio || 1;
            updatePixelSizes();

            wrapper.style.width = viewportWidth + 'px';
            wrapper.style.height = viewportHeight + 'px';

            console.clear();
            console.log('Viewport (window.innerWidth x window.innerHeight): ' +
                viewportWidth + ' x ' + viewportHeight);
            console.log('devicePixelRatio:', currentDpr);
            console.log('Note: border, pixel size and push box size are tied to devicePixelRatio.');

            // Clamp active dots to stay fully on screen
            const sizeCss = getPixelSizeCss();
            const half = sizeCss / 2;
            const minX = half;
            const maxX = viewportWidth - half;
            const minY = half;
            const maxY = viewportHeight - half;

            for (const key in dots) {
                const dot = dots[key];
                if (!dot.active) continue;
                if (dot.x < minX) dot.x = minX;
                if (dot.x > maxX) dot.x = maxX;
                if (dot.y < minY) dot.y = minY;
                if (dot.y > maxY) dot.y = maxY;
            }

            if (!frameFlashActive) {
                applyBaseFrameVisibility();
            }

            logState();
        }

        // Change pixel scale by delta (+1 or -1) and update sizes
        // Used to test halo behavior for different physical sizes of bright objects.
        function changePixelScale(delta) {
            const newScale = Math.max(minScale, pixelScale + delta); // no upper bound
            if (newScale === pixelScale) return;
            pixelScale = newScale;
            updatePixelSizes();

            // Re-clamp dots to keep them within screen edges
            const sizeCss = getPixelSizeCss();
            const half = sizeCss / 2;
            const minX = half;
            const maxX = viewportWidth - half;
            const minY = half;
            const maxY = viewportHeight - half;

            for (const key in dots) {
                const dot = dots[key];
                if (!dot.active) continue;
                if (dot.x < minX) dot.x = minX;
                if (dot.x > maxX) dot.x = maxX;
                if (dot.y < minY) dot.y = minY;
                if (dot.y > maxY) dot.y = maxY;
            }

            logState();
        }

        // Toggle base frame visibility (Space) – used to inspect edge glow/bleeding
        function toggleFrame() {
            frameBaseVisible = !frameBaseVisible;

            if (!frameFlashActive) {
                applyBaseFrameVisibility();
            }

            logState();
        }

        // Toggle a specific dot by key (1–4)
        function toggleDot(key) {
            const dot = dots[key];
            if (!dot) return;

            if (dot.active) {
                dot.active = false;
                dot.element.style.display = 'none';
            } else {
                dot.active = true;
                randomizeDotPositionAndVelocity(dot);
                dot.element.style.display = 'block';
                dot.element.style.backgroundColor = dot.color;
            }

            logState();
        }

        // Toggle group 5 (10 vivid colour pixels) – multi-color static halo test
        function toggleColorGroup() {
            createColorGroupDotsIfNeeded();
            updatePixelSizes();

            colorGroupActive = !colorGroupActive;

            if (colorGroupActive) {
                // Build vivid palette (all bright & distinct)
                const palette = buildVividPalette(COLOR_GROUP_COUNT);

                colorGroupDots.forEach((dot, index) => {
                    dot.active = true;
                    dot.color = palette[index % palette.length];
                    randomizeDotPositionAndVelocity(dot);
                    dot.element.style.display = 'block';
                    dot.element.style.backgroundColor = dot.color;
                });
            } else {
                // Deactivate group 5 pixels
                colorGroupDots.forEach(dot => {
                    dot.active = false;
                    dot.element.style.display = 'none';
                });
            }

            logState();
        }

        // Toggle group 6 (10 animated colour pixels) – gradient / animation halo test
        function toggleAnimatedGroup() {
            createAnimatedGroupDotsIfNeeded();
            updatePixelSizes();

            animatedGroupActive = !animatedGroupActive;

            if (animatedGroupActive) {
                animatedGroupDots.forEach(dot => {
                    dot.active = true;
                    dot.h = Math.random(); // random starting hue
                    dot.hSpeed = 0.0005 + Math.random() * 0.0015; // hue shift speed
                    dot.color = hsvToRgbCss(dot.h, 1.0, 1.0);
                    randomizeDotPositionAndVelocity(dot);
                    dot.element.style.display = 'block';
                    dot.element.style.backgroundColor = dot.color;
                });
            } else {
                // Deactivate group 6 pixels
                animatedGroupDots.forEach(dot => {
                    dot.active = false;
                    dot.element.style.display = 'none';
                });
            }

            logState();
        }

        // Flash the frame with the given color for a short time (wall collisions)
        // This lets you see how the panel handles sudden bright edges.
        function flashFrame(color) {
            frameFlashActive = true;
            frame.style.display = 'block';
            frame.style.borderColor = color;

            if (frameBaseVisible) {
                hud.style.color = color;
            }

            frameFlashEndTime = performance.now() + 80;
            logState();
        }

        // Create explosion at given center (cx, cy) with mixed color
        // Explosion is a square ring with thickness = current pixel scale
        // and radius up to 5 scales, lasting 1 second.
        function createExplosion(cx, cy, colors) {
            const explosionColor = mixColors(colors);
            const sizeCss = getPixelSizeCss();
            const maxRadius = sizeCss * 5;  // distance 5 scales (radius)

            const el = document.createElement('div');
            el.className = 'explosion';
            el.style.borderColor = explosionColor;
            el.style.opacity = '1';

            wrapper.appendChild(el);

            explosions.push({
                element: el,
                startTime: performance.now(),
                x: cx,
                y: cy,
                maxRadius: maxRadius
            });
        }

        // Keyboard handler (layout-independent for +/- using event.code)
        function handleKeyDown(event) {
            const code = event.code;

            // Space toggles frame
            if (code === 'Space') {
                event.preventDefault();
                toggleFrame();
                return;
            }

            // 1–4 by key value (number keys are stable enough)
            if (event.key === '1' || event.key === '2' ||
                event.key === '3' || event.key === '4') {
                event.preventDefault();
                toggleDot(event.key);
                return;
            }

            // 5 toggles group of 10 vivid colour pixels
            if (event.key === '5') {
                event.preventDefault();
                toggleColorGroup();
                return;
            }

            // 6 toggles group of 10 animated colour pixels
            if (event.key === '6') {
                event.preventDefault();
                toggleAnimatedGroup();
                return;
            }

            // Increase pixel scale:
            //   - 'Equal' -> physical key near Backspace (US: =/+)
            //   - 'NumpadAdd' -> plus on numpad
            if (code === 'Equal' || code === 'NumpadAdd') {
                event.preventDefault();
                changePixelScale(+1);
                return;
            }

            // Decrease pixel scale:
            //   - 'Minus' -> physical minus key near 0
            //   - 'NumpadSubtract' -> minus on numpad
            if (code === 'Minus' || code === 'NumpadSubtract') {
                event.preventDefault();
                changePixelScale(-1);
            }
        }

        // Capture all dots that are inside a specific push box at the moment of press
        function captureDotsInsidePushBox(box) {
            const sideCss = getPushBoxSideCss();
            const sizeCss = getPixelSizeCss();
            const halfDot = sizeCss / 2;
            const halfBox = sideCss / 2;
            const limitX = halfBox + halfDot;
            const limitY = halfBox + halfDot;

            for (const key in dots) {
                const dot = dots[key];
                if (!dot.active) continue;
                if (dot.captured) continue;

                const dx = dot.x - box.x;
                const dy = dot.y - box.y;

                if (Math.abs(dx) <= limitX && Math.abs(dy) <= limitY) {
                    dot.captured = true;
                    dot.capturedBy = box.pointerId;
                    dot.captureOffsetX = dx;
                    dot.captureOffsetY = dy;
                }
            }
        }

        // Helper: get position relative to wrapper
        function getRelativePosition(event) {
            const rect = wrapper.getBoundingClientRect();
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        }

        // Create a new push box for a given pointer
        function createPushBox(pointerId, event) {
            const pos = getRelativePosition(event);
            const sideCss = getPushBoxSideCss();
            const borderCss = getPushBoxBorderCss();

            const el = document.createElement('div');
            el.className = 'pushBox';
            el.style.display = 'block';
            el.style.width = sideCss + 'px';
            el.style.height = sideCss + 'px';
            el.style.borderWidth = borderCss + 'px';
            el.style.transform =
                'translate(' + (pos.x - sideCss / 2) + 'px, ' + (pos.y - sideCss / 2) + 'px)';

            wrapper.appendChild(el);

            const hue = Math.random();
            const color = hsvToRgbCss(hue, 1.0, 1.0);

            const box = {
                pointerId: pointerId,
                el: el,
                x: pos.x,
                y: pos.y,
                prevX: pos.x,
                prevY: pos.y,
                lastVx: 0,
                lastVy: 0,
                hue: hue,
                color: color
            };

            pushBoxes[pointerId] = box;

            // Capture pixels already inside this box
            captureDotsInsidePushBox(box);

            return box;
        }

        // Pointer handlers (mouse/touch)
        function handlePointerDown(event) {
            event.preventDefault();

            // Capture this pointer so we keep getting events even if it moves fast
            if (wrapper.setPointerCapture) {
                try {
                    wrapper.setPointerCapture(event.pointerId);
                } catch (e) {
                    // Ignore if capture is not supported
                }
            }

            if (!pushBoxes[event.pointerId]) {
                createPushBox(event.pointerId, event);
                logState();
            }
        }

        function handlePointerMove(event) {
            const box = pushBoxes[event.pointerId];
            if (!box) return;

            event.preventDefault();
            const pos = getRelativePosition(event);
            box.x = pos.x;
            box.y = pos.y;

            const sideCss = getPushBoxSideCss();
            box.el.style.transform =
                'translate(' + (box.x - sideCss / 2) + 'px, ' + (box.y - sideCss / 2) + 'px)';
        }

        function handlePointerUpOrCancel(event) {
            const box = pushBoxes[event.pointerId];
            if (!box) return;

            event.preventDefault();

            if (wrapper.releasePointerCapture) {
                try {
                    wrapper.releasePointerCapture(event.pointerId);
                } catch (e) {
                    // Ignore if not captured
                }
            }

            // Release captured dots belonging to this box
            for (const key in dots) {
                const dot = dots[key];
                if (!dot.captured || dot.capturedBy !== box.pointerId) continue;
                dot.captured = false;
                dot.capturedBy = null;
                dot.vx = box.lastVx;
                dot.vy = box.lastVy;
            }

            if (box.el && box.el.parentNode) {
                box.el.parentNode.removeChild(box.el);
            }
            delete pushBoxes[event.pointerId];

            logState();
        }

        // Animation loop: bounce from SCREEN EDGES, collide as squares, explosions, push-box interaction
        function animate() {
            const now = performance.now();

            // Frame flash timeout
            if (frameFlashActive && frameFlashEndTime > 0 && now > frameFlashEndTime) {
                frameFlashActive = false;
                frameFlashEndTime = 0;

                applyBaseFrameVisibility();
                hud.style.color = hudBaseColor;
                logState();
            }

            const sizeCss = getPixelSizeCss();
            const halfDot = sizeCss / 2;

            const minX = halfDot;                     // inner screen edge (left)
            const maxX = viewportWidth - halfDot;     // inner screen edge (right)
            const minY = halfDot;                     // inner screen edge (top)
            const maxY = viewportHeight - halfDot;    // inner screen edge (bottom)

            const activeBoxIds = Object.keys(pushBoxes);

            // Update push boxes: velocity, hue, CSS
            for (const id of activeBoxIds) {
                const box = pushBoxes[id];
                const sideCss = getPushBoxSideCss();
                const borderCss = getPushBoxBorderCss();

                const vx = box.x - box.prevX;
                const vy = box.y - box.prevY;
                box.prevX = box.x;
                box.prevY = box.y;
                box.lastVx = vx;
                box.lastVy = vy;

                box.hue += 0.003;
                if (box.hue > 1) box.hue -= 1;
                box.color = hsvToRgbCss(box.hue, 1.0, 1.0);

                const style = box.el.style;
                style.width = sideCss + 'px';
                style.height = sideCss + 'px';
                style.borderWidth = borderCss + 'px';
                style.borderColor = box.color;
                style.transform =
                    'translate(' + (box.x - sideCss / 2) + 'px, ' + (box.y - sideCss / 2) + 'px)';
            }

            const activeDots = [];

            // First pass: move dots, handle wall collisions, update animated colors
            for (const key in dots) {
                const dot = dots[key];
                if (!dot.active) continue;

                if (dot.captured && dot.capturedBy !== null) {
                    const box = pushBoxes[dot.capturedBy];
                    if (box) {
                        dot.x = box.x + dot.captureOffsetX;
                        dot.y = box.y + dot.captureOffsetY;
                        activeDots.push(dot);
                        continue;
                    } else {
                        dot.captured = false;
                        dot.capturedBy = null;
                    }
                }

                // Animated color update for group 6
                if (dot.groupKey === ANIMATED_GROUP_LABEL_KEY &&
                    typeof dot.h === 'number' &&
                    typeof dot.hSpeed === 'number') {
                    dot.h += dot.hSpeed;
                    if (dot.h > 1) dot.h -= 1;
                    const newColor = hsvToRgbCss(dot.h, 1.0, 1.0);
                    dot.color = newColor;
                    dot.element.style.backgroundColor = newColor;
                }

                dot.x += dot.vx;
                dot.y += dot.vy;

                let hitWall = false;

                // Bounce from screen edges
                if (dot.x <= minX) {
                    dot.x = minX;
                    dot.vx = Math.abs(dot.vx);
                    hitWall = true;
                } else if (dot.x >= maxX) {
                    dot.x = maxX;
                    dot.vx = -Math.abs(dot.vx);
                    hitWall = true;
                }

                if (dot.y <= minY) {
                    dot.y = minY;
                    dot.vy = Math.abs(dot.vy);
                    hitWall = true;
                } else if (dot.y >= maxY) {
                    dot.y = maxY;
                    dot.vy = -Math.abs(dot.vy);
                    hitWall = true;
                }

                if (hitWall) {
                    flashFrame(dot.color);
                }

                activeDots.push(dot);
            }

            // Second pass: handle collisions between dots as squares (AABB) + explosions
            for (let i = 0; i < activeDots.length; i++) {
                const a = activeDots[i];
                for (let j = i + 1; j < activeDots.length; j++) {
                    const b = activeDots[j];

                    const dx = b.x - a.x;
                    const dy = b.y - a.y;

                    // Check overlap of two squares (AABB in center-coordinates form)
                    if (Math.abs(dx) < sizeCss && Math.abs(dy) < sizeCss) {
                        // Compute overlap along each axis
                        const overlapX = sizeCss - Math.abs(dx);
                        const overlapY = sizeCss - Math.abs(dy);

                        // Approximate collision point as midpoint
                        const cx = (a.x + b.x) / 2;
                        const cy = (a.y + b.y) / 2;

                        // Create explosion with mixed color of both dots
                        createExplosion(cx, cy, [a.color, b.color]);

                        if (overlapX < overlapY) {
                            // Resolve along X axis
                            const correction = overlapX / 2;
                            if (dx > 0) {
                                // b is to the right of a
                                a.x -= correction;
                                b.x += correction;
                            } else {
                                // b is to the left of a
                                a.x += correction;
                                b.x -= correction;
                            }

                            // Elastic collision along X: swap vx
                            const tmpVx = a.vx;
                            a.vx = b.vx;
                            b.vx = tmpVx;
                        } else {
                            // Resolve along Y axis
                            const correction = overlapY / 2;
                            if (dy > 0) {
                                // b is below a
                                a.y -= correction;
                                b.y += correction;
                            } else {
                                // b is above a
                                a.y += correction;
                                b.y -= correction;
                            }

                            // Elastic collision along Y: swap vy
                            const tmpVy = a.vy;
                            a.vy = b.vy;
                            b.vy = tmpVy;
                        }

                        // Clamp back into screen bounds after correction
                        a.x = Math.max(minX, Math.min(maxX, a.x));
                        a.y = Math.max(minY, Math.min(maxY, a.y));
                        b.x = Math.max(minX, Math.min(maxX, b.x));
                        b.y = Math.max(minY, Math.min(maxY, b.y));
                    }
                }
            }

            // Third pass: interaction with all push boxes as squares (AABB) + explosions
            if (activeBoxIds.length > 0) {
                for (const id of activeBoxIds) {
                    const box = pushBoxes[id];
                    const sideCss = getPushBoxSideCss();
                    const halfBox = sideCss / 2;
                    const halfDotSize = halfDot;
                    const pushBoxVx = box.lastVx;
                    const pushBoxVy = box.lastVy;
                    const pushBoxColor = box.color;

                    for (const dot of activeDots) {
                        if (dot.captured) continue; // captured pixels just follow their box

                        const dx = dot.x - box.x;
                        const dy = dot.y - box.y;

                        // Minkowski sum: check overlap between big box and dot square
                        const overlapX = (halfBox + halfDotSize) - Math.abs(dx);
                        const overlapY = (halfBox + halfDotSize) - Math.abs(dy);

                        if (overlapX > 0 && overlapY > 0) {
                            let cx, cy; // collision point on the box border
                            let nx = 0, ny = 0; // collision normal

                            if (overlapX < overlapY) {
                                // Collision with left/right side
                                if (dx > 0) {
                                    // Right side
                                    nx = 1;
                                    cx = box.x + halfBox;
                                } else {
                                    // Left side
                                    nx = -1;
                                    cx = box.x - halfBox;
                                }
                                cy = dot.y;
                            } else {
                                // Collision with top/bottom side
                                if (dy > 0) {
                                    // Bottom
                                    ny = 1;
                                    cy = box.y + halfBox;
                                } else {
                                    // Top
                                    ny = -1;
                                    cy = box.y - halfBox;
                                }
                                cx = dot.x;
                            }

                            // Explosion color mixes pixel color and current box border color
                            createExplosion(cx, cy, [dot.color, pushBoxColor]);

                            // Push dot out of the box along collision normal
                            if (nx !== 0) {
                                dot.x += nx * overlapX;
                            } else if (ny !== 0) {
                                dot.y += ny * overlapY;
                            }

                            // Reflect velocity relative to moving box along the normal with restitution
                            const relVx = dot.vx - pushBoxVx;
                            const relVy = dot.vy - pushBoxVy;
                            const relDot = relVx * nx + relVy * ny; // projection on normal

                            // v' = v - (1 + e) * (v·n) * n
                            const factor = (1 + pushBoxRestitution) * relDot;
                            const newRelVx = relVx - factor * nx;
                            const newRelVy = relVy - factor * ny;

                            dot.vx = newRelVx + pushBoxVx;
                            dot.vy = newRelVy + pushBoxVy;

                            // Clamp back into screen bounds after correction
                            dot.x = Math.max(minX, Math.min(maxX, dot.x));
                            dot.y = Math.max(minY, Math.min(maxY, dot.y));
                        }
                    }
                }
            }

            // Fourth pass: apply CSS transforms based on updated positions
            for (const dot of activeDots) {
                dot.element.style.transform =
                    'translate(' + (dot.x - halfDot) + 'px, ' + (dot.y - halfDot) + 'px)';
            }

            // Fifth pass: update explosions (square wave expanding over time)
            const toRemove = [];
            for (let i = 0; i < explosions.length; i++) {
                const ex = explosions[i];
                const life = now - ex.startTime;
                const t = life / EXPLOSION_DURATION;

                if (t >= 1) {
                    toRemove.push(i);
                    continue;
                }

                const radius = ex.maxRadius * t;      // 0 -> maxRadius over 1s
                const size = radius * 2;             // width/height
                const borderWidth = getPixelSizeCss(); // thickness according to scale
                const opacity = 1 - t;

                ex.element.style.width = size + 'px';
                ex.element.style.height = size + 'px';
                ex.element.style.borderWidth = borderWidth + 'px';
                ex.element.style.left = (ex.x - radius) + 'px';
                ex.element.style.top = (ex.y - radius) + 'px';
                ex.element.style.opacity = opacity.toString();
            }

            // Remove finished explosions (from end to start)
            for (let k = toRemove.length - 1; k >= 0; k--) {
                const idx = toRemove[k];
                const ex = explosions[idx];
                if (ex && ex.element && ex.element.parentNode) {
                    ex.element.parentNode.removeChild(ex.element);
                }
                explosions.splice(idx, 1);
            }

            requestAnimationFrame(animate);
        }

        // Event listeners
        window.addEventListener('resize', resizeToViewport);
        window.addEventListener('keydown', handleKeyDown);

        // Pointer events for mouse/touch (supporting multiple fingers)
        wrapper.addEventListener('pointerdown', handlePointerDown);
        wrapper.addEventListener('pointermove', handlePointerMove);
        wrapper.addEventListener('pointerup', handlePointerUpOrCancel);
        wrapper.addEventListener('pointercancel', handlePointerUpOrCancel);
        wrapper.addEventListener('pointerleave', handlePointerUpOrCancel);

        window.addEventListener('load', function () {
            resizeToViewport();
            // Default behaviour: only mode 6 (animated colour pixels) is enabled
            toggleAnimatedGroup();
            requestAnimationFrame(animate);
        });
        document.addEventListener('DOMContentLoaded', resizeToViewport);
    })();
</script>
</body>
</html>